<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Celestial Path Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        canvas { cursor: grab; }
        canvas:active { cursor: grabbing; }
        
        /* Custom Styles for a nicer UI */
        .control-panel {
            scrollbar-width: thin;
            scrollbar-color: #4a5568 #2d3748;
        }
        .control-panel::-webkit-scrollbar { width: 8px; }
        .control-panel::-webkit-scrollbar-track { background: #2d3748; }
        .control-panel::-webkit-scrollbar-thumb { background-color: #4a5568; border-radius: 4px; }

        .form-input, .form-select {
            background-color: #2d3748;
            border-color: #4a5568;
            color: #e2e8f0;
        }
        .form-input:focus, .form-select:focus {
            --tw-ring-color: #2563eb;
            border-color: #2563eb;
        }
        .form-checkbox {
            color: #3b82f6;
            background-color: #4a5568;
            border-color: #718096;
        }
        .date-nav-btn {
            background-color: #4a5568;
            transition: background-color 0.2s;
        }
        .date-nav-btn:hover {
            background-color: #718096;
        }
        #search-results {
            max-height: 200px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #4a5568 #2d3748;
        }
        #search-results::-webkit-scrollbar { width: 5px; }
        #search-results::-webkit-scrollbar-track { background: #2d3748; }
        #search-results::-webkit-scrollbar-thumb { background-color: #4a5568; border-radius: 2px; }
        
        #info-panel-content::-webkit-scrollbar { height: 4px; }
        #info-panel-content::-webkit-scrollbar-track { background: #2d3748; }
        #info-panel-content::-webkit-scrollbar-thumb { background-color: #4a5568; border-radius: 2px; }


        /* Toggle Switch */
        .toggle-bg:after {
            content: '';
            @apply absolute top-0.5 left-0.5 bg-white border border-gray-300 rounded-full h-5 w-5 transition shadow-sm;
        }
        input:checked + .toggle-bg:after {
            transform: translateX(100%);
            @apply border-white;
        }
        input:checked + .toggle-bg {
            @apply bg-cyan-500;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex flex-col md:flex-row h-screen overflow-hidden">

    <!-- CONTROLS -->
    <div class="w-full md:w-96 bg-gray-800 p-6 shadow-2xl flex-shrink-0 overflow-y-auto control-panel flex flex-col">
        <div class="flex items-center gap-3 mb-6">
            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-cyan-400"><path d="M12 21a9 9 0 1 0 0-18 9 9 0 0 0 0 18Z"/><path d="M19 12H5"/><path d="m12 5 3.14 6.14L22 12l-6.86.86L12 19l-3.14-6.14L2 12l6.86-.86L12 5Z"/></svg>
            <h1 class="text-2xl font-bold text-cyan-400">Celestial Path</h1>
        </div>
        
        <div class="space-y-8">
            <!-- Mode Toggle -->
            <div>
                <label for="mode-toggle" class="flex items-center cursor-pointer">
                    <span class="mr-3 text-sm font-medium">Paths</span>
                    <div class="relative">
                        <input type="checkbox" id="mode-toggle" class="sr-only">
                        <div class="block bg-gray-600 w-10 h-6 rounded-full toggle-bg"></div>
                    </div>
                    <span class="ml-3 text-sm font-medium">Locations</span>
                </label>
            </div>

            <!-- Location & Time Controls -->
            <div>
                <div class="space-y-4">
                    <label class="block">
                        <span class="text-gray-400 text-sm font-medium">Location</span>
                        <select id="city-select" class="form-select w-full mt-1 rounded-md shadow-sm focus:ring-opacity-50">
                            <option value="kyiv">Kyiv</option>
                            <option value="amsterdam">Amsterdam</option>
                            <option value="barcelona">Barcelona</option>
                            <option value="newyork">New York</option>
                            <option value="saopaulo">SÃ£o Paulo</option>
                            <option value="tokyo">Tokyo</option>
                            <option value="sydney">Sydney</option>
                            <option value="cairo">Cairo</option>
                            <option value="buenosaires">Buenos Aires</option>
                            <option value="custom">Custom Coordinates</option>
                        </select>
                    </label>
                    <div>
                        <div class="flex items-end gap-2">
                            <label class="block flex-grow">
                                <span class="text-gray-400 text-sm font-medium">Coordinates (lat, lon)</span>
                                <input type="text" id="coordinates-input" class="form-input w-full mt-1 rounded-md shadow-sm focus:ring-opacity-50" placeholder="e.g., 40.71, -74.00">
                            </label>
                            <div id="custom-step-container" class="hidden">
                                <label class="block">
                                    <span class="text-gray-400 text-sm font-medium">Step</span>
                                    <select id="coord-step" class="form-select w-full mt-1 rounded-md shadow-sm">
                                        <option>10</option>
                                        <option>5</option>
                                        <option>1</option>
                                        <option>0.5</option>
                                        <option selected>0.1</option>
                                        <option>0.05</option>
                                        <option>0.01</option>
                                        <option>0.001</option>
                                        <option>0.0001</option>
                                    </select>
                                </label>
                            </div>
                        </div>
                        <div id="custom-nudge-container" class="hidden mt-2 flex justify-center items-center gap-2">
                            <button id="coord-left-btn" class="p-2 rounded-md date-nav-btn"><i data-lucide="chevron-left" class="w-5 h-5"></i></button>
                            <div class="flex flex-col gap-1">
                                <button id="coord-up-btn" class="p-2 rounded-md date-nav-btn"><i data-lucide="chevron-up" class="w-5 h-5"></i></button>
                                <button id="coord-down-btn" class="p-2 rounded-md date-nav-btn"><i data-lucide="chevron-down" class="w-5 h-5"></i></button>
                            </div>
                            <button id="coord-right-btn" class="p-2 rounded-md date-nav-btn"><i data-lucide="chevron-right" class="w-5 h-5"></i></button>
                        </div>
                    </div>
                    <div class="flex items-end gap-2">
                        <label class="block flex-grow">
                            <span class="text-gray-400 text-sm font-medium">Date</span>
                            <input type="date" id="date-picker" class="form-input w-full mt-1 rounded-md shadow-sm focus:ring-opacity-50" style="color-scheme: dark;">
                        </label>
                        <button id="prev-day-btn" class="p-2 rounded-md date-nav-btn"><i data-lucide="chevron-left" class="w-5 h-5"></i></button>
                        <button id="next-day-btn" class="p-2 rounded-md date-nav-btn"><i data-lucide="chevron-right" class="w-5 h-5"></i></button>
                    </div>
                    <div class="hidden" id="time-picker-container">
                         <div class="flex items-end gap-2">
                            <label class="block flex-grow">
                                <span class="text-gray-400 text-sm font-medium">Time</span>
                                <input type="time" id="time-picker" class="form-input w-full mt-1 rounded-md shadow-sm focus:ring-opacity-50" style="color-scheme: dark;">
                            </label>
                            <button id="prev-minute-btn" class="p-2 rounded-md date-nav-btn"><i data-lucide="chevron-left" class="w-5 h-5"></i></button>
                            <button id="next-minute-btn" class="p-2 rounded-md date-nav-btn"><i data-lucide="chevron-right" class="w-5 h-5"></i></button>
                        </div>
                    </div>
                    <label class="block">
                        <span class="text-gray-400 text-sm font-medium">Timezone (Label)</span>
                         <select id="timezone-select" class="form-select w-full mt-1 rounded-md shadow-sm focus:ring-opacity-50">
                            <option value="UTC">UTC</option>
                            <option value="local" selected>Local</option>
                        </select>
                    </label>
                </div>
            </div>

            <!-- Celestial Body Controls -->
            <div id="celestial-controls-container">
                <h2 class="text-lg font-semibold mb-3 border-b border-gray-600 pb-2">Celestial Bodies</h2>
                <div class="relative">
                    <input type="text" id="search-celestial" placeholder="Search for stars, galaxies..." class="form-input w-full rounded-md shadow-sm focus:ring-opacity-50">
                    <div id="search-results" class="absolute z-10 w-full bg-gray-700 rounded-md shadow-lg mt-1 hidden"></div>
                </div>
                <div id="celestial-options" class="space-y-2 mt-4">
                    <label class="p-2 rounded-md bg-gray-700/50 flex items-center"><input type="checkbox" data-celestial="sun" class="form-checkbox" checked> <span class="ml-3">Sun</span></label>
                    <label class="p-2 rounded-md bg-gray-700/50 flex items-center"><input type="checkbox" data-celestial="moon" class="form-checkbox" checked> <span class="ml-3">Moon</span></label>
                </div>
            </div>
        </div>
    </div>

    <!-- CANVAS & INFO PANEL -->
    <div class="flex-grow flex relative bg-gray-900">
        <canvas id="celestialCanvas" class="w-full h-full"></canvas>
        <div id="info-panel" class="absolute bottom-0 left-0 right-0 bg-gray-800 bg-opacity-90 p-3 shadow-inner text-sm overflow-hidden">
            <h3 id="info-panel-title" class="font-bold mb-2 text-center text-cyan-400"></h3>
            <div id="info-panel-content" class="flex items-center gap-x-4 overflow-x-auto pb-2 whitespace-nowrap">
                <!-- Content will be generated here -->
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            lucide.createIcons(); // Initialize icons

            // --- DOM ELEMENTS ---
            const canvas = document.getElementById('celestialCanvas');
            const ctx = canvas.getContext('2d');
            const datePicker = document.getElementById('date-picker');
            const citySelect = document.getElementById('city-select');
            const coordinatesInput = document.getElementById('coordinates-input');
            const timezoneSelect = document.getElementById('timezone-select');
            const celestialOptions = document.getElementById('celestial-options');
            const infoPanel = document.getElementById('info-panel');
            const infoPanelTitle = document.getElementById('info-panel-title');
            const infoPanelContent = document.getElementById('info-panel-content');
            const prevDayBtn = document.getElementById('prev-day-btn');
            const nextDayBtn = document.getElementById('next-day-btn');
            const searchInput = document.getElementById('search-celestial');
            const searchResults = document.getElementById('search-results');
            const modeToggle = document.getElementById('mode-toggle');
            const timePickerContainer = document.getElementById('time-picker-container');
            const timePicker = document.getElementById('time-picker');
            const celestialControlsContainer = document.getElementById('celestial-controls-container');
            const customStepContainer = document.getElementById('custom-step-container');
            const customNudgeContainer = document.getElementById('custom-nudge-container');
            const coordStep = document.getElementById('coord-step');
            const coordUpBtn = document.getElementById('coord-up-btn');
            const coordDownBtn = document.getElementById('coord-down-btn');
            const coordLeftBtn = document.getElementById('coord-left-btn');
            const coordRightBtn = document.getElementById('coord-right-btn');
            const prevMinuteBtn = document.getElementById('prev-minute-btn');
            const nextMinuteBtn = document.getElementById('next-minute-btn');


            // --- DATA ---
            const cities = {
                kyiv: { lat: 50.45, lon: 30.523, tzOffset: 3 },
                amsterdam: { lat: 52.367, lon: 4.904, tzOffset: 2 },
                barcelona: { lat: 41.385, lon: 2.173, tzOffset: 2 },
                newyork: { lat: 40.712, lon: -74.006, tzOffset: -4 },
                saopaulo: { lat: -23.55, lon: -46.633, tzOffset: -3 },
                tokyo: { lat: 35.6895, lon: 139.6917, tzOffset: 9 },
                sydney: { lat: -33.8688, lon: 151.2093, tzOffset: 10 },
                cairo: { lat: 30.0444, lon: 31.2357, tzOffset: 2 },
                buenosaires: { lat: -34.6037, lon: -58.3816, tzOffset: -3 },
                custom: { lat: 50.45, lon: 30.523, tzOffset: 0 } // Default to Kyiv, UTC. Updated by user input.
            };
            const celestialDb = {
                sun: { name: 'Sun', color: 'rgba(255, 235, 59, 1)' },
                moon: { name: 'Moon', color: 'rgba(200, 200, 220, 1)' },
                polaris: { ra: 2.58, dec: 89.26, name: 'Polaris', color: 'rgba(139, 195, 255, 1)' },
                sirius: { ra: 6.75, dec: -16.72, name: 'Sirius', color: 'rgba(255, 179, 128, 1)' },
                betelgeuse: { ra: 5.92, dec: 7.41, name: 'Betelgeuse', color: 'rgba(255, 100, 100, 1)' },
                rigel: { ra: 5.24, dec: -8.20, name: 'Rigel', color: 'rgba(173, 216, 230, 1)' },
                vega: { ra: 18.62, dec: 38.78, name: 'Vega', color: 'rgba(210, 210, 255, 1)' },
                arcturus: { ra: 14.26, dec: 19.18, name: 'Arcturus', color: 'rgba(255, 165, 0, 1)' },
                capella: { ra: 5.28, dec: 46.00, name: 'Capella', color: 'rgba(255, 255, 0, 1)' },
                procyon: { ra: 7.66, dec: 5.22, name: 'Procyon', color: 'rgba(255, 255, 224, 1)' },
                altair: { ra: 19.84, dec: 8.87, name: 'Altair', color: 'rgba(240, 248, 255, 1)' },
                deneb: { ra: 20.69, dec: 45.28, name: 'Deneb', color: 'rgba(220, 220, 255, 1)' },
                m31: { ra: 0.71, dec: 41.27, name: 'Andromeda Galaxy', color: 'rgba(200, 180, 255, 1)' },
                m42: { ra: 5.59, dec: -5.39, name: 'Orion Nebula', color: 'rgba(255, 182, 193, 1)' },
                m45: { ra: 3.79, dec: 24.12, name: 'Pleiades Cluster', color: 'rgba(173, 216, 230, 1)' },
                m33: { ra: 1.56, dec: 30.66, name: 'Triangulum Galaxy', color: 'rgba(200, 180, 255, 0.8)' },
            };
            const MIN_SCALE = 0.75;

            let scale = 1.0;
            let panOffset = { x: 0, y: 0 };
            let isPanning = false;
            let panStart = { x: 0, y: 0 };
            
            let drawScene;

            const updateCoordinatesInput = () => {
                const selectedCityKey = citySelect.value;
                if (cities[selectedCityKey]) {
                    const city = cities[selectedCityKey];
                    const lat = Number(city.lat);
                    const lon = Number(city.lon);
                    // Determine precision from step for custom coords, otherwise use 4 decimal places
                    let precision = 4;
                    if(selectedCityKey === 'custom') {
                        const stepStr = String(coordStep.value);
                        if(stepStr.includes('.')) {
                            precision = stepStr.split('.')[1].length;
                        } else {
                            precision = 0;
                        }
                    }
                    coordinatesInput.value = `${lat.toFixed(precision)}, ${lon.toFixed(precision)}`;
                }
            };

            const handleCoordinateChange = () => {
                const value = coordinatesInput.value.trim();
                const parts = value.split(/[\s,]+/);

                if (parts.length === 2) {
                    const lat = parseFloat(parts[0]);
                    const lon = parseFloat(parts[1]);

                    if (!isNaN(lat) && lat >= -90 && lat <= 90 && !isNaN(lon) && lon >= -180 && lon <= 180) {
                        cities.custom.lat = lat;
                        cities.custom.lon = lon;
                        
                        if (citySelect.value !== 'custom') {
                            citySelect.value = 'custom';
                            toggleCustomControls();
                        }
                        drawScene();
                    }
                }
            };

            const toggleCustomControls = () => {
                const show = citySelect.value === 'custom';
                customStepContainer.classList.toggle('hidden', !show);
                customNudgeContainer.classList.toggle('hidden', !show);
            };

            const nudgeCoordinates = (latChange, lonChange) => {
                const step = parseFloat(coordStep.value);
                let { lat, lon } = cities.custom;

                lat += latChange * step;
                lon += lonChange * step;

                // Clamp values
                lat = Math.max(-90, Math.min(90, lat));
                lon = Math.max(-180, Math.min(180, lon));
                
                cities.custom.lat = lat;
                cities.custom.lon = lon;

                updateCoordinatesInput();
                drawScene();
            };

            const init = () => {
                const now = new Date();
                datePicker.value = now.toISOString().split('T')[0];
                timePicker.value = now.toTimeString().slice(0,5);

                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                
                // General listeners
                [datePicker, timezoneSelect, celestialOptions, modeToggle, timePicker].forEach(el => {
                    el.addEventListener('change', () => drawScene());
                });

                // Specific listeners for location controls
                citySelect.addEventListener('change', () => {
                    if (citySelect.value !== 'custom') {
                        updateCoordinatesInput();
                    }
                    toggleCustomControls();
                    drawScene();
                });
                coordinatesInput.addEventListener('input', handleCoordinateChange);
                
                // Nudge button listeners
                coordUpBtn.addEventListener('click', () => nudgeCoordinates(1, 0));
                coordDownBtn.addEventListener('click', () => nudgeCoordinates(-1, 0));
                coordRightBtn.addEventListener('click', () => nudgeCoordinates(0, 1));
                coordLeftBtn.addEventListener('click', () => nudgeCoordinates(0, -1));
                coordStep.addEventListener('change', updateCoordinatesInput);

                prevDayBtn.addEventListener('click', () => changeDay(-1));
                nextDayBtn.addEventListener('click', () => changeDay(1));
                
                prevMinuteBtn.addEventListener('click', () => changeMinute(-1));
                nextMinuteBtn.addEventListener('click', () => changeMinute(1));

                searchInput.addEventListener('input', handleSearch);
                searchInput.addEventListener('focus', handleSearch);
                document.addEventListener('click', (e) => {
                    if (!searchResults.contains(e.target) && e.target !== searchInput) {
                        searchResults.classList.add('hidden');
                    }
                });

                canvas.addEventListener('wheel', handleZoom);
                canvas.addEventListener('mousedown', startPan);
                canvas.addEventListener('mousemove', doPan);
                canvas.addEventListener('mouseup', endPan);
                canvas.addEventListener('mouseleave', endPan);
                
                toggleCustomControls();
                updateCoordinatesInput();
                drawScene();
            };

            const resizeCanvas = () => {
                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                ctx.scale(dpr, dpr);
                if (drawScene) {
                    drawScene();
                }
            };

            const changeDay = (offset) => {
                const currentDate = new Date(datePicker.value);
                currentDate.setUTCDate(currentDate.getUTCDate() + offset);
                datePicker.value = currentDate.toISOString().split('T')[0];
                drawScene();
            };
            
            const changeMinute = (offset) => {
                const [hours, minutes] = timePicker.value.split(':').map(Number);
                const date = new Date(); // Temporary date to do calculations
                date.setHours(hours);
                date.setMinutes(minutes + offset);
                
                const newHours = String(date.getHours()).padStart(2, '0');
                const newMinutes = String(date.getMinutes()).padStart(2, '0');
                
                timePicker.value = `${newHours}:${newMinutes}`;
                drawScene();
            };
            
            const handleSearch = (e) => {
                const query = e.target.value.toLowerCase();
                if (query.length < 1) {
                    searchResults.classList.add('hidden');
                    return;
                }
                const results = Object.entries(celestialDb).filter(([id, obj]) => 
                    id !== 'sun' && id !== 'moon' && obj.name.toLowerCase().includes(query)
                );
                
                searchResults.innerHTML = '';
                if (results.length > 0) {
                    results.forEach(([id, obj]) => {
                        const div = document.createElement('div');
                        div.className = 'p-2 hover:bg-gray-600 cursor-pointer';
                        div.textContent = obj.name;
                        div.dataset.id = id;
                        div.addEventListener('click', selectCelestialObject);
                        searchResults.appendChild(div);
                    });
                    searchResults.classList.remove('hidden');
                } else {
                    searchResults.classList.add('hidden');
                }
            };

            const selectCelestialObject = (e) => {
                const id = e.target.dataset.id;
                const obj = celestialDb[id];
                searchInput.value = '';
                searchResults.classList.add('hidden');
                
                if (document.querySelector(`input[data-celestial="${id}"]`)) {
                    return;
                }

                const label = document.createElement('label');
                label.className = 'p-2 rounded-md bg-gray-700/50 flex items-center justify-between';
                label.innerHTML = `
                    <div class="flex items-center">
                        <input type="checkbox" data-celestial="${id}" class="form-checkbox" checked>
                        <span class="ml-3">${obj.name}</span>
                    </div>
                    <button data-remove-id="${id}" class="text-gray-500 hover:text-red-400">&times;</button>
                `;
                celestialOptions.appendChild(label);
                
                label.querySelector(`button[data-remove-id="${id}"]`).addEventListener('click', (e) => {
                    e.preventDefault();
                    label.remove();
                    drawScene();
                });

                drawScene();
            };

            drawScene = () => {
                const isLocationMode = modeToggle.checked;
                timePickerContainer.classList.toggle('hidden', !isLocationMode);
                celestialControlsContainer.classList.toggle('hidden', isLocationMode);

                const { width, height } = canvas.getBoundingClientRect();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#111827';
                ctx.fillRect(0, 0, width, height);
                
                ctx.save();
                ctx.translate(width / 2 + panOffset.x, height / 2 + panOffset.y);
                ctx.scale(scale, scale);
                
                const radius = Math.min(width, height) * 0.4;
                drawGrid(radius);

                const city = cities[citySelect.value];
                
                if (isLocationMode) {
                    const dateStr = datePicker.value;
                    const timeStr = timePicker.value;
                    const isUTC = timezoneSelect.value === 'UTC';
                    const dateString = `${dateStr}T${timeStr}:00${isUTC ? 'Z' : ''}`;
                    const selectedDate = new Date(dateString);
                    generateLocationInfo(selectedDate, city);
                    drawAllObjectLocations(selectedDate, city, radius);
                } else {
                    generateHourlyLegend();
                    const selectedDate = new Date(datePicker.value + 'T00:00:00Z');
                    const drawnLabels = [];
                    document.querySelectorAll('#celestial-options input:checked').forEach(cb => {
                        const id = cb.dataset.celestial;
                        const obj = celestialDb[id];
                        if (id === 'sun' || id === 'moon') {
                            drawCelestialPath(selectedDate, city, id, radius, obj.color, obj.name, drawnLabels);
                        } else {
                            drawObjectPath(selectedDate, city, obj, radius, obj.color, obj.name, drawnLabels);
                        }
                    });
                }
                
                ctx.restore();
            };

            const drawAllObjectLocations = (date, city, radius) => {
                Object.entries(celestialDb).forEach(([id, obj]) => {
                    let getPosFunc;
                    if (id === 'sun') {
                        getPosFunc = (d) => SunCalc.getPosition(d, city.lat, city.lon);
                    } else if (id === 'moon') {
                        getPosFunc = (d) => SunCalc.getMoonPosition(d, city.lat, city.lon);
                    } else {
                        getPosFunc = (d) => raDecToAzAlt(obj.ra, obj.dec, city.lat, city.lon, d);
                    }

                    const pos = getPosFunc(date);
                    if (pos.altitude > 0) {
                        const { x, y } = getCanvasCoords(pos.azimuth, pos.altitude, radius);
                        ctx.beginPath();
                        ctx.arc(x, y, 5 / scale, 0, 2 * Math.PI);
                        ctx.fillStyle = obj.color;
                        ctx.fill();
                        
                        ctx.fillStyle = 'white';
                        ctx.font = `${12 / scale}px Inter`;
                        ctx.fillText(obj.name, x, y - 15 / scale);
                    }
                });
            };

            const drawGrid = (radius) => {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `${10 / scale}px Inter`;

                for (let i = 10; i <= 80; i += 10) {
                    const r = radius * (1 - i / 90);
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, 2 * Math.PI);
                    ctx.setLineDash([2, 4]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    if (scale > 1.1) {
                        ctx.fillText(`${i}Â°`, r, 5 / scale);
                        ctx.fillText(`${i}Â°`, -r, 5 / scale);
                        ctx.fillText(`${i}Â°`, 0, r + 5/scale);
                        ctx.fillText(`${i}Â°`, 0, -r + 5/scale);
                    }
                }

                const compass = { 'N': 0, 'NNE': 22.5, 'NE': 45, 'ENE': 67.5, 'E': 90, 'ESE': 112.5, 'SE': 135, 'SSE': 157.5, 'S': 180, 'SSW': 202.5, 'SW': 225, 'WSW': 247.5, 'W': 270, 'WNW': 292.5, 'NW': 315, 'NNW': 337.5 };
                Object.entries(compass).forEach(([dir, angleDeg]) => {
                    const angleRad = toRad(angleDeg - 90);
                    const isMajor = angleDeg % 90 === 0;
                    const isMinor = angleDeg % 45 === 0;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(radius * Math.cos(angleRad), radius * Math.sin(angleRad));
                    ctx.strokeStyle = isMajor ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.15)';
                    ctx.stroke();
                    if (isMajor || (scale > 1.2 && isMinor) || scale > 2.5) {
                        ctx.font = `${(isMajor ? 14 : 10) / scale}px Inter`;
                        const x = (radius + 20 / scale) * Math.cos(angleRad);
                        const y = (radius + 20 / scale) * Math.sin(angleRad);
                        ctx.fillText(dir, x, y);
                    }
                    if (scale > 1.5 && !isMajor) {
                        ctx.save();
                        ctx.font = `${8 / scale}px Inter`;
                        ctx.translate(radius * 0.6 * Math.cos(angleRad), radius * 0.6 * Math.sin(angleRad));
                        ctx.rotate(angleRad + Math.PI / 2);
                        ctx.fillText(`${angleDeg}Â°`, 0, 0);
                        ctx.restore();
                    }
                });
            };
            const drawCelestialPath = (date, city, type, radius, color, name, drawnLabels) => {
                const getPosFunc = (d) => type === 'sun' ? SunCalc.getPosition(d, city.lat, city.lon) : SunCalc.getMoonPosition(d, city.lat, city.lon);
                drawPath(date, city, radius, color, name, getPosFunc, drawnLabels);
                let times = type === 'sun' ? SunCalc.getTimes(date, city.lat, city.lon) : SunCalc.getMoonTimes(date, city.lat, city.lon, true);
                if (type === 'sun') {
                    if (!times.rise && times.sunrise) times.rise = times.sunrise;
                    if (!times.set && times.sunset) times.set = times.sunset;
                }
                const riseLabel = type === 'sun' ? 'Sunrise' : 'Moonrise';
                const setLabel = type === 'sun' ? 'Sunset' : 'Moonset';
                drawRiseSetLabels(times, city, radius, color, riseLabel, setLabel, getPosFunc);
            };
            const drawObjectPath = (date, city, object, radius, color, name, drawnLabels) => {
                const getPosFunc = (d) => raDecToAzAlt(object.ra, object.dec, city.lat, city.lon, d);
                drawPath(date, city, radius, color, name, getPosFunc, drawnLabels);
                const times = findRiseSet(date, city, getPosFunc);
                drawRiseSetLabels(times, city, radius, color, `${name} Rise`, `${name} Set`, getPosFunc);
            };
            const drawPath = (date, city, radius, color, name, getPosFunc, drawnLabels) => {
                ctx.strokeStyle = color;
                ctx.fillStyle = color;
                ctx.lineWidth = 2 / scale;
                const pathPoints = [];
                const tzOffsetHours = timezoneSelect.value === 'local' && citySelect.value !== 'custom' ? city.tzOffset : 0;
                ctx.beginPath();
                let lastPos = null;
                for (let i = 0; i <= 24 * 60; i += 5) {
                    const loopDate = new Date(date.getTime() + i * 60 * 1000);
                    const pos = getPosFunc(loopDate);
                    if (pos.altitude > 0) {
                        const { x, y } = getCanvasCoords(pos.azimuth, pos.altitude, radius);
                        if (lastPos === null || lastPos.altitude <= 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                        pathPoints.push({x, y});
                    }
                    lastPos = pos;
                }
                ctx.stroke();
                for (let hour = 0; hour < 24; hour++) {
                    const hourDate = new Date(date.getTime() + hour * 3600 * 1000);
                    const pos = getPosFunc(hourDate);
                    if (pos.altitude > 0) {
                        const { x, y } = getCanvasCoords(pos.azimuth, pos.altitude, radius);
                        ctx.beginPath();
                        ctx.arc(x, y, 4 / scale, 0, 2 * Math.PI);
                        const hue = (hour * 15 + 60) % 360;
                        ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                        ctx.fill();
                        if (scale > 1.8) {
                            const displayHour = (hour + tzOffsetHours + 24) % 24;
                            const label = `${String(displayHour).padStart(2, '0')}:00`;
                            const labelBox = { x: x - 15/scale, y: y - 20/scale, w: 30/scale, h: 10/scale };
                            let overlaps = drawnLabels.some(box => labelBox.x < box.x + box.w && labelBox.x + labelBox.w > box.x && labelBox.y < box.y + box.h && labelBox.y + labelBox.h > box.y);
                            if (!overlaps) {
                                ctx.fillStyle = 'white';
                                ctx.font = `${10 / scale}px Inter`;
                                ctx.fillText(label, x, y - 12 / scale);
                                drawnLabels.push(labelBox);
                            }
                        }
                    }
                }
                if (pathPoints.length > 0) {
                    const midPoint = pathPoints[Math.floor(pathPoints.length / 2)];
                    ctx.fillStyle = color;
                    ctx.font = `bold ${14 / scale}px Inter`;
                    ctx.fillText(name, midPoint.x, midPoint.y - 20 / scale);
                }
            };
            const drawRiseSetLabels = (times, city, radius, color, riseLabel, setLabel, getPosFunc) => {
                ctx.fillStyle = color;
                ctx.font = `${11 / scale}px Inter`;
                const tzOffsetHours = timezoneSelect.value === 'local' && citySelect.value !== 'custom' ? city.tzOffset : 0;
                const formatTime = (d) => {
                    if (!d || isNaN(d)) return '';
                    const localTime = new Date(d.getTime() + tzOffsetHours * 3600 * 1000);
                    return localTime.toUTCString().match(/(\d\d:\d\d)/)[0];
                };
                if (times.rise) {
                    const risePos = getPosFunc(times.rise);
                    const {x, y} = getCanvasCoords(risePos.azimuth, 0, radius);
                    ctx.fillText(`${riseLabel}: ${formatTime(times.rise)}`, x, y - 10 / scale);
                }
                if (times.set) {
                    const setPos = getPosFunc(times.set);
                    const {x, y} = getCanvasCoords(setPos.azimuth, 0, radius);
                    ctx.fillText(`${setLabel}: ${formatTime(times.set)}`, x, y + 15 / scale);
                }
            };
            const getCanvasCoords = (azimuth, altitude, radius) => {
                const angle = azimuth + Math.PI / 2;
                const r = radius * (1 - (altitude / (Math.PI / 2)));
                return { x: r * Math.cos(angle), y: r * Math.sin(angle) };
            };
            const toRad = (deg) => deg * Math.PI / 180;
            const toDeg = (rad) => rad * 180 / Math.PI;
            
            const radToCompass = (rad) => {
                const compass = { 'N': 0, 'NNE': 22.5, 'NE': 45, 'ENE': 67.5, 'E': 90, 'ESE': 112.5, 'SE': 135, 'SSE': 157.5, 'S': 180, 'SSW': 202.5, 'SW': 225, 'WSW': 247.5, 'W': 270, 'WNW': 292.5, 'NW': 315, 'NNW': 337.5 };
                // Azimuth is south-based, clockwise. Convert to degrees, north-based, clockwise.
                let deg = (toDeg(rad) + 180) % 360;
                let closestDir = 'N';
                let minDiff = 360;
                Object.entries(compass).forEach(([dir, angleDeg]) => {
                    let diff = Math.abs(deg - angleDeg);
                    if (diff > 180) diff = 360 - diff; // Handle wrap-around
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestDir = dir;
                    }
                });
                return closestDir;
            };

            const generateHourlyLegend = () => {
                infoPanelTitle.textContent = 'Hourly Legend (UTC)';
                infoPanelContent.innerHTML = '';
                infoPanelContent.classList.add('justify-center');
                infoPanelContent.classList.remove('justify-start');

                [0, 3, 6, 9, 12, 15, 18, 21].forEach(hour => {
                    const hue = (hour * 15 + 60) % 360;
                    const color = `hsl(${hue}, 100%, 50%)`;
                    const div = document.createElement('div');
                    div.className = 'flex items-center gap-2';
                    div.innerHTML = `<div class="w-4 h-4 rounded-full" style="background-color: ${color};"></div><span>${String(hour).padStart(2, '0')}:00</span>`;
                    infoPanelContent.appendChild(div);
                });
            };

            const generateLocationInfo = (date, city) => {
                infoPanelTitle.textContent = `Celestial Positions at ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
                infoPanelContent.innerHTML = '';
                infoPanelContent.classList.remove('justify-center');
                infoPanelContent.classList.add('justify-start');

                const visibleObjects = [];
                Object.entries(celestialDb).forEach(([id, obj]) => {
                    let getPosFunc;
                    if (id === 'sun') {
                        getPosFunc = (d) => SunCalc.getPosition(d, city.lat, city.lon);
                    } else if (id === 'moon') {
                        getPosFunc = (d) => SunCalc.getMoonPosition(d, city.lat, city.lon);
                    } else {
                        getPosFunc = (d) => raDecToAzAlt(obj.ra, obj.dec, city.lat, city.lon, d);
                    }
                    const pos = getPosFunc(date);
                    if (pos.altitude > 0) {
                        const altDeg = toDeg(pos.altitude);
                        const azDegNorth = (toDeg(pos.azimuth) + 180) % 360;
                        const compass = radToCompass(pos.azimuth);
                        const infoString = `<span class="font-bold" style="color:${obj.color};">${obj.name}</span> ${altDeg.toFixed(2)}Â°, ${azDegNorth.toFixed(2)}Â° ${compass}`;
                        visibleObjects.push(infoString);
                    }
                });

                if (visibleObjects.length > 0) {
                    infoPanelContent.innerHTML = visibleObjects.join('<span class="text-gray-500 mx-2">â¢</span>');
                } else {
                    infoPanelContent.innerHTML = '<span class="text-gray-400">No celestial objects visible above the horizon.</span>';
                    infoPanelContent.classList.add('justify-center');
                }
            };

            const getLST = (date, lon) => {
                const jd = date.getTime() / 86400000 + 2440587.5;
                const d = jd - 2451545.0;
                const gmst = 18.697374558 + 24.06570982441908 * d;
                return (gmst + lon / 15 + 24) % 24;
            };

            const raDecToAzAlt = (ra, dec, lat, lon, date) => {
                const lst = getLST(date, lon);
                const ha = toRad((lst - ra) * 15);
                const latRad = toRad(lat), decRad = toRad(dec);
                const altRad = Math.asin(Math.sin(decRad) * Math.sin(latRad) + Math.cos(decRad) * Math.cos(latRad) * Math.cos(ha));
                const azRad = Math.acos((Math.sin(decRad) - Math.sin(altRad) * Math.sin(latRad)) / (Math.cos(altRad) * Math.cos(latRad)));
                let northAzimuth = Math.sin(ha) > 0 ? 2 * Math.PI - azRad : azRad;
                let southAzimuth = (northAzimuth + Math.PI) % (2 * Math.PI);
                return { altitude: altRad, azimuth: southAzimuth }; 
            };
            const findRiseSet = (date, city, getPosFunc) => {
                let rise, set;
                let lastAlt = getPosFunc(date).altitude;
                for (let i = 1; i <= 24 * 60; i++) {
                    const loopDate = new Date(date.getTime() + i * 60 * 1000);
                    const alt = getPosFunc(loopDate).altitude;
                    if (!rise && lastAlt < 0 && alt >= 0) rise = loopDate;
                    if (!set && lastAlt >= 0 && alt < 0) set = loopDate;
                    lastAlt = alt;
                }
                return { rise, set };
            };
            const handleZoom = (event) => {
                event.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouse = { x: event.clientX - rect.left, y: event.clientY - rect.top };
                const zoomFactor = 1.1;
                const oldScale = scale;
                let newScale = event.deltaY < 0 ? scale * zoomFactor : scale / zoomFactor;
                newScale = Math.max(MIN_SCALE, Math.min(newScale, 10));
                if (newScale === oldScale) return;
                
                const scaleChange = newScale - oldScale;
                const panX = mouse.x - rect.width / 2;
                const panY = mouse.y - rect.height / 2;
                panOffset.x -= (panX - panOffset.x) * (scaleChange / oldScale);
                panOffset.y -= (panY - panOffset.y) * (scaleChange / oldScale);
                scale = newScale;
                
                if (scale <= MIN_SCALE) {
                    panOffset = { x: 0, y: 0 };
                }
                
                drawScene();
            };
            const startPan = (event) => { isPanning = true; panStart = { x: event.clientX - panOffset.x, y: event.clientY - panOffset.y }; };
            const doPan = (event) => {
                if (isPanning) {
                    const { width, height } = canvas.getBoundingClientRect();
                    const radius = Math.min(width, height) * 0.4;
                    panOffset.x = event.clientX - panStart.x;
                    panOffset.y = event.clientY - panStart.y;
                    const maxPan = radius * Math.max(0, scale - 1) + radius * 0.2;
                    const currentPanMagnitude = Math.sqrt(panOffset.x**2 + panOffset.y**2);
                    if (currentPanMagnitude > maxPan) {
                        panOffset.x = (panOffset.x / currentPanMagnitude) * maxPan;
                        panOffset.y = (panOffset.y / currentPanMagnitude) * maxPan;
                    }
                    drawScene();
                }
            };
            const endPan = () => { isPanning = false; };
            
            init();
        });
    </script>
</body>
</html>

