<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Celestial Path Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/suncalc/1.9.0/suncalc.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        .control-panel label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        canvas {
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
        /* Style for custom select arrow */
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23CBD5E0%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right .7em top 50%;
            background-size: .65em auto;
            padding-right: 2em;
        }
        .form-checkbox {
            color: #2563eb;
            background-color: #4a5568;
            border-color: #718096;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col md:flex-row h-screen overflow-hidden">

    <!-- CONTROLS -->
    <div class="w-full md:w-80 bg-gray-800 p-6 shadow-lg flex-shrink-0 overflow-y-auto control-panel">
        <h1 class="text-2xl font-bold mb-6 text-cyan-400">Celestial Path</h1>
        
        <div class="space-y-6">
            <div>
                <h2 class="text-lg font-semibold mb-3 border-b border-gray-600 pb-2">1. Celestial Bodies</h2>
                <div id="celestial-options" class="space-y-2">
                    <label><input type="checkbox" data-celestial="sun" class="form-checkbox" checked> <span>Sun</span></label>
                    <label><input type="checkbox" data-celestial="moon" class="form-checkbox" checked> <span>Moon</span></label>
                    <label><input type="checkbox" data-celestial="polaris" class="form-checkbox"> <span>Polaris</span></label>
                    <label><input type="checkbox" data-celestial="sirius" class="form-checkbox"> <span>Sirius</span></label>
                </div>
            </div>

            <div>
                <h2 class="text-lg font-semibold mb-3 border-b border-gray-600 pb-2">2. Location</h2>
                <label class="block">
                    <span class="text-gray-400">City</span>
                    <select id="city-select" class="w-full mt-1 bg-gray-700 border-gray-500 rounded-md shadow-sm focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50">
                        <option value="kyiv">Kyiv</option>
                        <option value="amsterdam">Amsterdam</option>
                        <option value="barcelona">Barcelona</option>
                        <option value="newyork">New York</option>
                        <option value="saopaulo">São Paulo</option>
                    </select>
                </label>
            </div>

            <div>
                <h2 class="text-lg font-semibold mb-3 border-b border-gray-600 pb-2">3. Time & Date</h2>
                <label class="block">
                    <span class="text-gray-400">Timezone (Label)</span>
                     <select id="timezone-select" class="w-full mt-1 bg-gray-700 border-gray-500 rounded-md shadow-sm focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50">
                        <option value="UTC">UTC</option>
                        <option value="local" selected>Local</option>
                    </select>
                </label>
                <label class="block mt-4">
                    <span class="text-gray-400">Date</span>
                    <input type="date" id="date-picker" class="w-full mt-1 bg-gray-700 border-gray-500 rounded-md shadow-sm focus:border-cyan-500 focus:ring focus:ring-cyan-500 focus:ring-opacity-50" style="color-scheme: dark;">
                </label>
            </div>
        </div>
    </div>

    <!-- CANVAS & LEGEND -->
    <div class="flex-grow flex relative bg-gray-900">
        <canvas id="celestialCanvas" class="w-full h-full"></canvas>
        
        <div id="legend" class="absolute bottom-4 right-4 bg-gray-800 bg-opacity-80 p-4 rounded-lg shadow-xl text-sm">
            <h3 class="font-bold mb-2 text-center">Hourly Legend (UTC)</h3>
            <div class="grid grid-cols-4 gap-x-4 gap-y-2"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('celestialCanvas');
            const ctx = canvas.getContext('2d');
            const datePicker = document.getElementById('date-picker');
            const citySelect = document.getElementById('city-select');
            const timezoneSelect = document.getElementById('timezone-select');
            const celestialOptions = document.getElementById('celestial-options');
            const legend = document.getElementById('legend').querySelector('div');

            const cities = {
                kyiv: { lat: 50.45, lon: 30.523, tzOffset: 3 },
                amsterdam: { lat: 52.367, lon: 4.904, tzOffset: 2 },
                barcelona: { lat: 41.385, lon: 2.173, tzOffset: 2 },
                newyork: { lat: 40.712, lon: -74.006, tzOffset: -4 },
                saopaulo: { lat: -23.55, lon: -46.633, tzOffset: -3 }
            };
            const celestialObjects = {
                sun: { name: 'Sun', color: 'rgba(255, 235, 59, 1)' },
                moon: { name: 'Moon', color: 'rgba(200, 200, 220, 1)' },
                polaris: { ra: 2.58, dec: 89.26, name: 'Polaris', color: 'rgba(139, 195, 255, 1)' },
                sirius: { ra: 6.75, dec: -16.72, name: 'Sirius', color: 'rgba(255, 179, 128, 1)' }
            };
            const MIN_SCALE = 0.75;

            let scale = 1.0;
            let panOffset = { x: 0, y: 0 };
            let isPanning = false;
            let panStart = { x: 0, y: 0 };
            
            const init = () => {
                datePicker.value = new Date().toISOString().split('T')[0];
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
                
                [datePicker, citySelect, timezoneSelect, celestialOptions].forEach(el => {
                    el.addEventListener('change', drawScene);
                });

                canvas.addEventListener('wheel', handleZoom);
                canvas.addEventListener('mousedown', startPan);
                canvas.addEventListener('mousemove', doPan);
                canvas.addEventListener('mouseup', endPan);
                canvas.addEventListener('mouseleave', endPan);
                
                drawScene();
                generateLegend();
            };

            const resizeCanvas = () => {
                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                ctx.scale(dpr, dpr);
                drawScene();
            };

            const drawScene = () => {
                const { width, height } = canvas.getBoundingClientRect();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#111827';
                ctx.fillRect(0, 0, width, height);
                
                ctx.save();
                ctx.translate(width / 2 + panOffset.x, height / 2 + panOffset.y);
                ctx.scale(scale, scale);
                
                const radius = Math.min(width, height) * 0.4;
                drawGrid(radius);

                const selectedDate = new Date(datePicker.value + 'T00:00:00Z');
                const city = cities[citySelect.value];
                const drawnLabels = [];

                document.querySelectorAll('#celestial-options input:checked').forEach(cb => {
                    const id = cb.dataset.celestial;
                    const obj = celestialObjects[id];
                    if (id === 'sun' || id === 'moon') {
                        drawCelestialPath(selectedDate, city, id, radius, obj.color, obj.name, drawnLabels);
                    } else {
                        drawObjectPath(selectedDate, city, obj, radius, obj.color, obj.name, drawnLabels);
                    }
                });
                
                ctx.restore();
            };

            const drawGrid = (radius) => {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Altitude circles
                ctx.font = `${10 / scale}px Inter`;
                for (let i = 10; i <= 90; i += 10) {
                    const r = radius * (1 - i / 90);
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, 2 * Math.PI);
                    ctx.setLineDash([2, 4]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.fillText(`${i}°`, r * Math.cos(-Math.PI/4), r * Math.sin(-Math.PI/4));
                }

                // Compass Rose
                const compass = {
                    'N': 0, 'NNE': 22.5, 'NE': 45, 'ENE': 67.5,
                    'E': 90, 'ESE': 112.5, 'SE': 135, 'SSE': 157.5,
                    'S': 180, 'SSW': 202.5, 'SW': 225, 'WSW': 247.5,
                    'W': 270, 'WNW': 292.5, 'NW': 315, 'NNW': 337.5
                };
                
                Object.entries(compass).forEach(([dir, angleDeg]) => {
                    const angleRad = toRad(angleDeg - 90);
                    const isMajor = angleDeg % 90 === 0;
                    const isMinor = angleDeg % 45 === 0;

                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(radius * Math.cos(angleRad), radius * Math.sin(angleRad));
                    ctx.strokeStyle = isMajor ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.15)';
                    ctx.stroke();
                    
                    if (isMajor || (scale > 1.2 && isMinor) || scale > 2.5) {
                        ctx.font = `${(isMajor ? 14 : 10) / scale}px Inter`;
                        const x = (radius + 20 / scale) * Math.cos(angleRad);
                        const y = (radius + 20 / scale) * Math.sin(angleRad);
                        ctx.fillText(dir, x, y);
                    }
                });
            };
            
            const drawCelestialPath = (date, city, type, radius, color, name, drawnLabels) => {
                const getPosFunc = (d) => {
                    const pos = type === 'sun' ? SunCalc.getPosition(d, city.lat, city.lon) : SunCalc.getMoonPosition(d, city.lat, city.lon);
                    return pos;
                };
                drawPath(date, city, radius, color, name, getPosFunc, drawnLabels);
                
                let times = type === 'sun' ? SunCalc.getTimes(date, city.lat, city.lon) : SunCalc.getMoonTimes(date, city.lat, city.lon, true);
                
                if (type === 'sun') {
                    if (!times.rise && times.sunrise) times.rise = times.sunrise;
                    if (!times.set && times.sunset) times.set = times.sunset;
                }

                const riseLabel = type === 'sun' ? 'Sunrise' : 'Moonrise';
                const setLabel = type === 'sun' ? 'Sunset' : 'Moonset';
                
                drawRiseSetLabels(times, city, radius, color, riseLabel, setLabel, getPosFunc);
            };

            const drawObjectPath = (date, city, object, radius, color, name, drawnLabels) => {
                const getPosFunc = (d) => {
                    const northPos = raDecToAzAlt(object.ra, object.dec, city.lat, city.lon, d);
                    northPos.azimuth = (northPos.azimuth + Math.PI) % (2 * Math.PI);
                    return northPos;
                };
                drawPath(date, city, radius, color, name, getPosFunc, drawnLabels);

                const times = findRiseSet(date, city, getPosFunc);
                drawRiseSetLabels(times, city, radius, color, `${name} Rise`, `${name} Set`, getPosFunc);
            };

            const drawPath = (date, city, radius, color, name, getPosFunc, drawnLabels) => {
                ctx.strokeStyle = color;
                ctx.fillStyle = color;
                ctx.lineWidth = 2 / scale;
                
                const pathPoints = [];
                const tzOffsetHours = timezoneSelect.value === 'local' ? city.tzOffset : 0;

                ctx.beginPath();
                let lastPos = null;

                for (let i = 0; i <= 24 * 60; i += 5) {
                    const loopDate = new Date(date.getTime() + i * 60 * 1000);
                    const pos = getPosFunc(loopDate);
                    
                    if (pos.altitude > 0) {
                        const { x, y } = getCanvasCoords(pos.azimuth, pos.altitude, radius);
                        
                        if (lastPos === null || lastPos.altitude <= 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                        pathPoints.push({x, y});
                    }
                    lastPos = pos;
                }
                ctx.stroke();

                for (let hour = 0; hour < 24; hour++) {
                    const hourDate = new Date(date.getTime() + hour * 3600 * 1000);
                    const pos = getPosFunc(hourDate);
                    if (pos.altitude > 0) {
                        const { x, y } = getCanvasCoords(pos.azimuth, pos.altitude, radius);
                        ctx.beginPath();
                        ctx.arc(x, y, 4 / scale, 0, 2 * Math.PI);
                        const hue = (hour * 15 + 60) % 360;
                        ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                        ctx.fill();

                        if (scale > 1.8) {
                            const displayHour = (hour + tzOffsetHours + 24) % 24;
                            const label = `${String(displayHour).padStart(2, '0')}:00`;
                            const labelBox = { x: x - 15/scale, y: y - 20/scale, w: 30/scale, h: 10/scale };
                            
                            let overlaps = drawnLabels.some(box => 
                                labelBox.x < box.x + box.w && labelBox.x + labelBox.w > box.x &&
                                labelBox.y < box.y + box.h && labelBox.y + labelBox.h > box.y
                            );
                            if (!overlaps) {
                                ctx.fillStyle = 'white';
                                ctx.font = `${10 / scale}px Inter`;
                                ctx.fillText(label, x, y - 12 / scale);
                                drawnLabels.push(labelBox);
                            }
                        }
                    }
                }

                if (pathPoints.length > 0) {
                    const midPoint = pathPoints[Math.floor(pathPoints.length / 2)];
                    ctx.fillStyle = color;
                    ctx.font = `bold ${14 / scale}px Inter`;
                    ctx.fillText(name, midPoint.x, midPoint.y - 20 / scale);
                }
            };
            
            const drawRiseSetLabels = (times, city, radius, color, riseLabel, setLabel, getPosFunc) => {
                ctx.fillStyle = color;
                ctx.font = `${11 / scale}px Inter`;
                const tzOffsetHours = timezoneSelect.value === 'local' ? city.tzOffset : 0;
                const formatTime = (d) => {
                    if (!d || isNaN(d)) return '';
                    const localTime = new Date(d.getTime() + tzOffsetHours * 3600 * 1000);
                    return localTime.toUTCString().match(/(\d\d:\d\d)/)[0];
                };

                if (times.rise) {
                    const risePos = getPosFunc(times.rise);
                    const {x, y} = getCanvasCoords(risePos.azimuth, 0, radius);
                    ctx.fillText(`${riseLabel}: ${formatTime(times.rise)}`, x, y - 10 / scale);
                }
                if (times.set) {
                    const setPos = getPosFunc(times.set);
                    const {x, y} = getCanvasCoords(setPos.azimuth, 0, radius);
                    ctx.fillText(`${setLabel}: ${formatTime(times.set)}`, x, y + 15 / scale);
                }
            };

            const getCanvasCoords = (azimuth, altitude, radius) => {
                const angle = azimuth + Math.PI / 2;
                const r = radius * (1 - (altitude / (Math.PI / 2)));
                return { x: r * Math.cos(angle), y: r * Math.sin(angle) };
            };
            
            const generateLegend = () => {
                legend.innerHTML = '';
                [0, 3, 6, 9, 12, 15, 18, 21].forEach(hour => {
                    const hue = (hour * 15 + 60) % 360;
                    const color = `hsl(${hue}, 100%, 50%)`;
                    legend.innerHTML += `<div class="flex items-center gap-2"><div class="w-4 h-4 rounded-full" style="background-color: ${color};"></div><span>${String(hour).padStart(2, '0')}:00</span></div>`;
                });
            };

            const toRad = (deg) => deg * Math.PI / 180;
            const getLST = (date, lon) => {
                const jd = date.getTime() / 86400000 + 2440587.5;
                const d = jd - 2451545.0;
                const gmst = 18.697374558 + 24.06570982441908 * d;
                return (gmst + lon / 15 + 24) % 24;
            };
            const raDecToAzAlt = (ra, dec, lat, lon, date) => {
                const lst = getLST(date, lon);
                const ha = toRad((lst - ra) * 15);
                const latRad = toRad(lat), decRad = toRad(dec);
                const altRad = Math.asin(Math.sin(decRad) * Math.sin(latRad) + Math.cos(decRad) * Math.cos(latRad) * Math.cos(ha));
                const azRad = Math.acos((Math.sin(decRad) - Math.sin(altRad) * Math.sin(latRad)) / (Math.cos(altRad) * Math.cos(latRad)));
                let azimuth = Math.sin(ha) > 0 ? 2 * Math.PI - azRad : azRad;
                return { altitude: altRad, azimuth: azimuth }; 
            };
            const findRiseSet = (date, city, getPosFunc) => {
                let rise, set;
                let lastAlt = getPosFunc(date).altitude;
                for (let i = 1; i <= 24 * 60; i++) {
                    const loopDate = new Date(date.getTime() + i * 60 * 1000);
                    const alt = getPosFunc(loopDate).altitude;
                    if (!rise && lastAlt < 0 && alt >= 0) rise = loopDate;
                    if (!set && lastAlt >= 0 && alt < 0) set = loopDate;
                    lastAlt = alt;
                }
                return { rise, set };
            };

            const handleZoom = (event) => {
                event.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouse = { x: event.clientX - rect.left, y: event.clientY - rect.top };
                
                const zoomFactor = 1.1;
                const oldScale = scale;
                let newScale = event.deltaY < 0 ? scale * zoomFactor : scale / zoomFactor;
                
                newScale = Math.max(MIN_SCALE, Math.min(newScale, 10));

                if (newScale === oldScale) return;

                if (newScale <= MIN_SCALE) {
                    scale = MIN_SCALE;
                    panOffset = { x: 0, y: 0 };
                } else {
                    const scaleChange = newScale - oldScale;
                    const panX = mouse.x - rect.width / 2;
                    const panY = mouse.y - rect.height / 2;
                    
                    panOffset.x -= (panX - panOffset.x) * (scaleChange / oldScale);
                    panOffset.y -= (panY - panOffset.y) * (scaleChange / oldScale);
                    scale = newScale;
                }
                
                drawScene();
            };

            const startPan = (event) => { isPanning = true; panStart = { x: event.clientX - panOffset.x, y: event.clientY - panOffset.y }; };
            
            const doPan = (event) => {
                if (isPanning) {
                    const { width, height } = canvas.getBoundingClientRect();
                    const radius = Math.min(width, height) * 0.4;
                    
                    panOffset.x = event.clientX - panStart.x;
                    panOffset.y = event.clientY - panStart.y;

                    const maxPan = radius * Math.max(0, scale - 1) + radius * 0.2;
                    const currentPanMagnitude = Math.sqrt(panOffset.x**2 + panOffset.y**2);

                    if (currentPanMagnitude > maxPan) {
                        panOffset.x = (panOffset.x / currentPanMagnitude) * maxPan;
                        panOffset.y = (panOffset.y / currentPanMagnitude) * maxPan;
                    }
                    drawScene();
                }
            };
            const endPan = () => { isPanning = false; };
            
            init();
        });
    </script>
</body>
</html>
