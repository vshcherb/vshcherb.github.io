<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Earth with Day Slider, Moon, Sun/Moon Positions, Shadow & Zoom</title>
    <style>
        body {
            margin: 0;
            font-family: 'Inter', sans-serif;
            background-color: #000;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden; /* Prevent scrollbars from appearing due to canvas/controls */
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        canvas {
            display: block; /* Remove extra space below canvas */
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(40, 40, 60, 0.85); /* Darker, slightly transparent background */
            padding: 15px;
            border-radius: 12px; /* Softer rounded corners */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3); /* More pronounced shadow */
            border: 1px solid rgba(255, 255, 255, 0.2); /* Subtle border */
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 12px; /* Space between control groups */
        }
        #controls label {
            font-size: 0.9em;
            margin-bottom: 3px;
        }
        #controls input[type="date"],
        #controls input[type="range"],
        #controls button {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #555; /* Slightly lighter border for inputs */
            background-color: #333; /* Dark input background */
            color: #fff;
            font-size: 0.9em;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        #controls button:hover {
            background-color: #444; /* Darker hover for buttons */
        }
        #controls input[type="range"] {
            width: 150px; /* Fixed width for sliders */
        }
        #timeValue, #tileZoomValue, #dayOfYearValue, #moonDistanceFactorValue, #sunDistanceFactorValue { /* Added new value displays */
            font-size: 0.9em;
            margin-left: 8px;
            min-width: 45px; /* Ensure consistent width for value displays */
            display: inline-block;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .button-group {
            display: flex;
            gap: 8px;
        }
        .button-group-shift {
            /*display: flex;*/
            display: none;
            gap: 8px;
        }
        #messageBox {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 100, 100, 0.9); /* Default to error-like color, will be changed by JS */
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            z-index: 1000;
            display: none; /* Hidden by default */
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            font-size: 0.9em;
            text-align: center;
        }
        /* Style for Celestial Point Display */
        
        #overallInfo {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(40, 40, 60, 0.85);
            padding: 10px 15px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 10;
            font-size: 0.9em;
            line-height: 1.4;
            text-align: right;
            display: block; /* Hidden initially */
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="canvas-container">
        </div>
    <div id="controls">
        <div class="control-group">
            <label>Camera:</label>
            <div class="button-group">
                <button id="zoomInBtn">+</button>
                <button id="zoomOutBtn">-</button>
                
                <button id="hideEarthBtn">Hide</button>
            </div>
            <div class="button-group-shift">
                <button id="shiftLeftBtn">←</button>
                <button id="shiftTopBtn">↑</button>
                <button id="shiftBotBtn">↓</button>
                <button id="shiftRightBtn">→</button>
            </div>
            
        </div>
        <div class="control-group">
            <label for="datePicker">Date:</label>
            <input type="date" id="datePicker">
        </div>
         <div class="control-group">
            <label for="dayOfYearSlider">Day of Year:</label>
            <div>
                <input type="range" id="dayOfYearSlider" min="1" max="366" value="1"> <span id="dayOfYearValue">1</span>
            </div>
        </div>
        <div class="control-group">
            <label for="timeSlider">Time (UTC):</label>
            <div>
                <input type="range" id="timeSlider" min="0" max="1439" value="1080">
                <span id="timeValue">18:00</span>
            </div>
        </div>
        <div class="control-group">
            <label for="tileZoomSlider">Map Tile Zoom (z):</label>
            <div>
                <input type="range" id="tileZoomSlider" min="3" max="6" value="3">
                <span id="tileZoomValue">3</span>
            </div>
        </div>
        <div class="control-group">
            <label for="moonDistanceFactorSlider">Moon Visual Dist. Factor:</label>
            <div>
                <input type="range" id="moonDistanceFactorSlider" min="1" max="30" value="1" step="0.1">
                <span id="moonDistanceFactorValue">1.0x</span>
            </div>
        </div>
        <div class="control-group">
            <label for="sunDistanceFactorSlider">Sun Visual Dist. Factor:</label>
            <div>
                <input type="range" id="sunDistanceFactorSlider" min="1" max="30" value="1" step="0.1">
                <span id="sunDistanceFactorValue">1.0x</span>
            </div>
        </div>
    </div>

    <div id="overallInfo">
        <div id="earthInfo">Calculating...</div>
        <div id="celestialInfo">Calculating...</div>
    </div>
    <div id="messageBox"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // --- Global Variables ---
        let scene, camera, renderer, earthMesh, sunLight, controls, moonMesh, moonProjectionMesh;
        let sunMesh; // Mesh for the Sun globe
        let sunProjectionMesh; // Mesh to show subsolar point
        let northPoleMeshGlobal, southPoleMeshGlobal; // Meshes for polar caps
        let currentTileZoomLevel = 4; // Initial tile zoom level for map
        let moonShadowMesh; // Mesh for the Moon's umbra (shadow)
        let currentMoonDistanceFactor = 1.0;
        let currentSunDistanceFactor = 1.0;
        let _infoRaycaster = new THREE.Raycaster(); // For updateEarthInfo
        let _viewDirection = new THREE.Vector3(); 
        

        // --- Constants ---
        const EARTH_RADIUS = 5; // Arbitrary radius for Earth in scene units
        const CAMERA_SHIFT_AMOUNT = EARTH_RADIUS / 5;
        const MOON_DISTANCE = 60.3; // Actual average distance from Earth to Moon in Earth radii
        const SUN_DISTANCE = 23460; // Actual average distance from Earth to Sun in Earth radii
        const MOON_RADIUS = EARTH_RADIUS / 3.67; // Relative Moon radius
        const SUN_RADIUS_IN_EARTH_RADII = 109.0; // Sun's radius relative to Earth's radius
        // VISUAL_MOON_DISTANCE_FACTOR is now replaced by dynamic slider

        // Constants for Moon's Umbra (shadow)
        const MOON_SHADOW_COLOR = 0x4A2A00; // Dark orange for the shadow
        const MOON_SHADOW_OPACITY = 0.75;   // Opacity of the shadow
        const ECLIPSE_UMBRA_RADIUS_ON_EARTH_SCENE_UNITS = 0.35; // Visual radius of the umbra on Earth in scene units.
        const ECLIPSE_THRESHOLD_ANGLE_RAD = (0.60 * Math.PI / 180); // Max angular separation (Sun-Earth-Moon) to show umbra (degrees to radians)
                                                                   // A small angle means Sun and Moon must be closely aligned. Increased slightly for better visibility of shadow.

        const TILE_SERVER_URL_SCHEME = 'https://tile.openstreetmap.org/{z}/{x}/{y}.png'; // URL scheme for map tiles
        const TILE_CANVAS_SIZE = 4096; // Resolution of the canvas used to stitch map tiles

        // DOM Elements
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const shiftRightBtn = document.getElementById('shiftRightBtn');
        const shiftLeftBtn = document.getElementById('shiftLeftBtn');
        const shiftTopBtn = document.getElementById('shiftTopBtn');
        const shiftBotBtn = document.getElementById('shiftBotBtn');
        const hideEarthBtn = document.getElementById('hideEarthBtn');
        const datePicker = document.getElementById('datePicker');
        const dayOfYearSlider = document.getElementById('dayOfYearSlider');
        const dayOfYearValueDisplay = document.getElementById('dayOfYearValue');
        const timeSlider = document.getElementById('timeSlider');
        const timeValueDisplay = document.getElementById('timeValue');
        const tileZoomSlider = document.getElementById('tileZoomSlider');
        const tileZoomValueDisplay = document.getElementById('tileZoomValue');
        const moonDistanceFactorSlider = document.getElementById('moonDistanceFactorSlider');
        const moonDistanceFactorValue = document.getElementById('moonDistanceFactorValue');
        const sunDistanceFactorSlider = document.getElementById('sunDistanceFactorSlider');
        const sunDistanceFactorValue = document.getElementById('sunDistanceFactorValue');
        const canvasContainer = document.getElementById('canvas-container');
        const messageBox = document.getElementById('messageBox');
        const celestialInfoDiv = document.getElementById('celestialInfo');
        const earthInfoDiv = document.getElementById('earthInfo');

        // --- Helper Functions ---
        // Checks if a given year is a leap year
        function isLeap(year) {
            return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
        }

        // Gets the day number (1-365 or 1-366) for a given UTC date
        function getDayOfYear(date) {
            const start = new Date(Date.UTC(date.getUTCFullYear(), 0, 0)); // Start of the year
            const diff = date.getTime() - start.getTime(); // Difference in milliseconds
            const oneDay = 1000 * 60 * 60 * 24; // Milliseconds in a day
            return Math.floor(diff / oneDay);
        }

        // Gets a UTC date from a year and a day number
        function getDateFromDay(year, day) {
            const date = new Date(Date.UTC(year, 0)); // Initialize to Jan 1st of the year
            return new Date(date.setUTCDate(day)); // Set the day of the year
        }

        // Formats a Date object into YYYY-MM-DD string
        function formatDate(date) {
            const yyyy = date.getUTCFullYear();
            const mm = String(date.getUTCMonth() + 1).padStart(2, '0'); // Months are 0-indexed
            const dd = String(date.getUTCDate()).padStart(2, '0');
            return `${yyyy}-${mm}-${dd}`;
        }

        // --- Initialization ---
        async function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510); // Dark space background

            // Camera setup
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, EARTH_RADIUS * SUN_DISTANCE * 1.2); // Adjusted far plane
            camera.position.set(0, 0, EARTH_RADIUS * 5); // Initial camera position
            camera.lookAt(0, 0, 0); // Look at the center of the scene (Earth)

            const nearPlaneCenterMarkerGeometry = new THREE.CircleGeometry(0.001, 16); 
            const nearPlaneCenterMarkerMaterial = new THREE.MeshBasicMaterial({
                color: 0xbb0000,        // Bright red for visibility
                side: THREE.DoubleSide, // Render both sides
                transparent:true,
                opacity:0.4
            });
            const nearPlaneCenterMarker = new THREE.Mesh(nearPlaneCenterMarkerGeometry, nearPlaneCenterMarkerMaterial);
            nearPlaneCenterMarker.position.set(0, 0,  -camera.near*2);
            camera.add(nearPlaneCenterMarker);

            scene.add(camera);
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // For sharp rendering on high DPI screens
            canvasContainer.appendChild(renderer.domElement); // Add canvas to the container

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x606060, 1.5); // Soft ambient light
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(0xffffff, 3.0); // Main light source (Sun)
            scene.add(sunLight);


            // --- Sun Globe ---
            const sunGeometry = new THREE.SphereGeometry(EARTH_RADIUS * SUN_RADIUS_IN_EARTH_RADII, 64, 64);
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xFFE45A, wireframe: false }); // Bright yellow, non-emissive for simplicity
            sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.visible = false; // Initially hidden until position is calculated
            scene.add(sunMesh);


            // --- Sun Projection Circle (Subsolar Point Marker) ---
            const sunProjGeom = new THREE.CircleGeometry(EARTH_RADIUS * 0.008, 32); // Small circle
            const sunProjMat = new THREE.MeshBasicMaterial({ color: 0xFFFF00, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
            sunProjectionMesh = new THREE.Mesh(sunProjGeom, sunProjMat);
            sunProjectionMesh.visible = false; // Initially hidden
            scene.add(sunProjectionMesh);

            // --- Moon Projection Circle (Sublunar Point Marker) ---
            const moonProjGeom = new THREE.CircleGeometry(EARTH_RADIUS * 0.008, 32); // Small circle
            const moonProjMat = new THREE.MeshBasicMaterial({ color: 0xAAAAFF, transparent: true, opacity: 0.6, side: THREE.DoubleSide }); // Light blue/grey
            moonProjectionMesh = new THREE.Mesh(moonProjGeom, moonProjMat);
            moonProjectionMesh.visible = false; // Initially hidden
            scene.add(moonProjectionMesh);


            // --- Moon ---
            const moonGeometry = new THREE.SphereGeometry(MOON_RADIUS, 32, 32);
            const moonMaterial = new THREE.MeshPhongMaterial({ color: 0xaaaaaa, shininess: 5, specular: 0x111111 });
            moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
            scene.add(moonMesh);

            // --- Moon Shadow (Umbra) ---
            const shadowGeometry = new THREE.CircleGeometry(ECLIPSE_UMBRA_RADIUS_ON_EARTH_SCENE_UNITS, 32);
            const shadowMaterial = new THREE.MeshBasicMaterial({
                color: MOON_SHADOW_COLOR,
                transparent: true,
                opacity: MOON_SHADOW_OPACITY,
                side: THREE.DoubleSide
            });
            moonShadowMesh = new THREE.Mesh(shadowGeometry, shadowMaterial);
            moonShadowMesh.visible = false; // Initially hidden
            scene.add(moonShadowMesh);


            // --- Earth ---
            try {
                await updateEarthTiles(currentTileZoomLevel); // Load initial map tiles
                // Initial date setup and sync
                //const today = new Date(); // Original
                const today = new Date("2026-08-12T"+timeValueDisplay.textContent+":00Z"); // Example date, ensure UTC interpretation
                datePicker.value = formatDate(today);
                syncDaySliderToDate(); // Sync day slider to the initial date

                // Initialize slider values from HTML defaults
                currentMoonDistanceFactor = parseFloat(moonDistanceFactorSlider.value);
                moonDistanceFactorValue.textContent = `${currentMoonDistanceFactor.toFixed(1)}x`;
                currentSunDistanceFactor = parseFloat(sunDistanceFactorSlider.value);
                sunDistanceFactorValue.textContent = `${currentSunDistanceFactor.toFixed(1)}x`;

                updateCelestialPositions(); // Calculate initial Sun/Moon positions
            } catch (error) {
                console.error("Error during initial scene setup:", error);
                showMessage("Failed to initialize Earth. Please refresh.", "error", 10000);
            }



            // --- Controls (OrbitControls for camera interaction) ---
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Smooth camera movement
            controls.dampingFactor = 0.05;
            controls.minDistance = EARTH_RADIUS + 0.1; // Prevent zooming inside Earth
            controls.maxDistance = EARTH_RADIUS * SUN_DISTANCE * 1.1; // Adjusted max zoom out
            controls.enablePan = true; // Disable panning

            // --- UI Event Listeners ---
            zoomInBtn.addEventListener('click', () => zoomCamera(0.8));
            zoomOutBtn.addEventListener('click', () => zoomCamera(1.25));
            shiftLeftBtn.addEventListener('click', () => shiftEarth(0, 1));
            shiftRightBtn.addEventListener('click', () => shiftEarth(0, -1));
            shiftTopBtn.addEventListener('click', () => shiftEarth(1, -1));
            shiftBotBtn.addEventListener('click', () => shiftEarth(1, 1));
            hideEarthBtn.addEventListener('click', () => {
                hideEarthBtn.textContent = earthMesh.visible ? "Show" : "Hide";
                earthMesh.visible = !earthMesh.visible
            });
            datePicker.addEventListener('change', () => {
                syncDaySliderToDate();
                updateCelestialPositions();
            });

            dayOfYearSlider.addEventListener('input', () => {
                syncDateToDaySlider();
                updateCelestialPositions();
            });

            timeSlider.addEventListener('input', () => {
                const minutes = parseInt(timeSlider.value);
                const h = Math.floor(minutes / 60);
                const m = minutes % 60;
                timeValueDisplay.textContent = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
                updateCelestialPositions();
            });

            tileZoomSlider.addEventListener('input', async (event) => {
                const newZoomLevel = parseInt(event.target.value);
                tileZoomValueDisplay.textContent = newZoomLevel;
                if (newZoomLevel !== currentTileZoomLevel) {
                    currentTileZoomLevel = newZoomLevel;
                    showMessage(`Loading tiles for zoom level ${currentTileZoomLevel}... This may take a moment.`, "info", 0);
                    await updateEarthTiles(currentTileZoomLevel);
                    updateCelestialPositions();
                }
            });

            moonDistanceFactorSlider.addEventListener('input', () => {
                currentMoonDistanceFactor = parseFloat(moonDistanceFactorSlider.value);
                moonDistanceFactorValue.textContent = `${currentMoonDistanceFactor.toFixed(1)}x`;
                updateCelestialPositions();
            });

            sunDistanceFactorSlider.addEventListener('input', () => {
                currentSunDistanceFactor = parseFloat(sunDistanceFactorSlider.value);
                sunDistanceFactorValue.textContent = `${currentSunDistanceFactor.toFixed(1)}x`;
                updateCelestialPositions();
            });


            window.addEventListener('resize', onWindowResize);
            controls.addEventListener('change', function() {
                updateEarthInfo();
            });
            animate();
            updateEarthInfo();
        }

        // --- Date/Day Slider Synchronization ---
        function syncDaySliderToDate() {
            const dateStr = datePicker.value;
            if (!dateStr) return;
            const year = parseInt(dateStr.substring(0, 4));
            const month = parseInt(dateStr.substring(5, 7)) - 1;
            const day = parseInt(dateStr.substring(8, 10));
            const currentUtcDate = new Date(Date.UTC(year, month, day));
            const dayNum = getDayOfYear(currentUtcDate);
            dayOfYearSlider.max = isLeap(year) ? 366 : 365;
            dayOfYearSlider.value = dayNum;
            dayOfYearValueDisplay.textContent = dayNum;
        }

        function syncDateToDaySlider() {
            const dayNum = parseInt(dayOfYearSlider.value);
            const dateStr = datePicker.value;
            let year = new Date().getUTCFullYear();
             if (dateStr) {
                 year = parseInt(dateStr.substring(0, 4));
             } else {
                 datePicker.value = formatDate(getDateFromDay(year, 1));
             }
            dayOfYearSlider.max = isLeap(year) ? 366 : 365;
            const newDate = getDateFromDay(year, dayNum);
            datePicker.value = formatDate(newDate);
            dayOfYearValueDisplay.textContent = dayNum;
        }


        // --- Mercator Tile to Geographic Coordinate Helpers ---
        function tile2lon(x, z) { return x / Math.pow(2, z) * 360 - 180; }
        function tile2lat(y, z) { const n = Math.PI - 2 * Math.PI * y / Math.pow(2, z); return 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n))); }
        function getTileGeoBounds(tileX, tileY, zoom) {
            const lon1 = tile2lon(tileX, zoom); const lat1 = tile2lat(tileY, zoom);
            const lon2 = tile2lon(tileX + 1, zoom); const lat2 = tile2lat(tileY + 1, zoom);
            return { minLon: lon1, maxLon: lon2, minLat: lat2, maxLat: lat1 };
        }

        // --- Earth Tile Update ---
        async function updateEarthTiles(zoomLevel) {
             if (earthMesh) {
                scene.remove(earthMesh);
                if (earthMesh.geometry) earthMesh.geometry.dispose();
                if (earthMesh.material && earthMesh.material.map) earthMesh.material.map.dispose();
                if (earthMesh.material) earthMesh.material.dispose();
                earthMesh = null;
            }
            if(northPoleMeshGlobal && northPoleMeshGlobal.parent) northPoleMeshGlobal.parent.remove(northPoleMeshGlobal);
            if(southPoleMeshGlobal && southPoleMeshGlobal.parent) southPoleMeshGlobal.parent.remove(southPoleMeshGlobal);
            northPoleMeshGlobal = null; southPoleMeshGlobal = null;

            const earthGeometry = new THREE.SphereGeometry(EARTH_RADIUS, 128, 128);
            const numTilesPerDimension = Math.pow(2, zoomLevel);
            const tilesToLoad = [];
            for (let y = 0; y < numTilesPerDimension; y++) { for (let x = 0; x < numTilesPerDimension; x++) { tilesToLoad.push({ z: zoomLevel, x: x, y: y }); } }

            const tileCanvas = document.createElement('canvas');
            tileCanvas.width = TILE_CANVAS_SIZE; tileCanvas.height = TILE_CANVAS_SIZE;
            const ctx = tileCanvas.getContext('2d');
            ctx.fillStyle = '#102030';
            ctx.fillRect(0, 0, tileCanvas.width, tileCanvas.height);

            const textureLoader = new THREE.TextureLoader();
            textureLoader.setCrossOrigin("anonymous");
            let loadedCount = 0; const totalTiles = tilesToLoad.length; let progressLastShown = 0;

            const promises = tilesToLoad.map(tileInfo => {
                const tileUrl = TILE_SERVER_URL_SCHEME.replace('{z}', tileInfo.z).replace('{x}', tileInfo.x).replace('{y}', tileInfo.y);
                return new Promise((resolve) => {
                    textureLoader.load(tileUrl, (texture) => {
                            const image = texture.image;
                            try {
                                const geoBounds = getTileGeoBounds(tileInfo.x, tileInfo.y, zoomLevel);
                                const destX = ((geoBounds.minLon + 180) / 360) * TILE_CANVAS_SIZE;
                                const destMaxX = ((geoBounds.maxLon + 180) / 360) * TILE_CANVAS_SIZE;
                                const destY = ((90 - geoBounds.maxLat) / 180) * TILE_CANVAS_SIZE;
                                const destMaxY = ((90 - geoBounds.minLat) / 180) * TILE_CANVAS_SIZE;
                                const destWidth = destMaxX - destX; const destHeight = destMaxY - destY;
                                if (destWidth > 0 && destHeight > 0) { ctx.drawImage(image, 0, 0, image.width, image.height, destX, destY, destWidth, destHeight); }
                            } catch (e) { console.error(`Error processing/drawing tile ${tileUrl} to canvas:`, e); }
                            loadedCount++; const progress = Math.floor((loadedCount / totalTiles) * 100);
                            if (progress > progressLastShown + 5 || loadedCount === totalTiles) {
                                showMessage(`Loading tiles: ${progress}% complete...`, "loading", loadedCount === totalTiles ? 1000 : 0); progressLastShown = progress;
                            } resolve();
                        }, undefined, (error) => {
                            console.error(`Failed to load tile image: ${tileUrl}`, error);
                            drawErrorPlaceholder(ctx, tileInfo.x * (TILE_CANVAS_SIZE / numTilesPerDimension), tileInfo.y * (TILE_CANVAS_SIZE / numTilesPerDimension), (TILE_CANVAS_SIZE / numTilesPerDimension), zoomLevel, tileInfo.x, tileInfo.y, "LoadErr");
                            loadedCount++; const progress = Math.floor((loadedCount / totalTiles) * 100);
                             if (progress > progressLastShown + 5 || loadedCount === totalTiles) {
                                showMessage(`Loading tiles (some errors): ${progress}% complete...`, "loading", loadedCount === totalTiles ? 1000 : 0); progressLastShown = progress;
                            } resolve();
                        } ); }); });

            await Promise.all(promises);
            showMessage(`All ${totalTiles} tile requests for zoom ${zoomLevel} processed.`, "info", 4000);

            const earthTexture = new THREE.CanvasTexture(tileCanvas);
            earthTexture.colorSpace = THREE.SRGBColorSpace;
            earthTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            earthTexture.needsUpdate = true;
            const earthMaterial = new THREE.MeshPhongMaterial({ map: earthTexture, shininess: 10, specular: 0x101010 });
            earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
            scene.add(earthMesh);
            createPolarCaps(earthMesh);
        }

        function drawErrorPlaceholder(context, canvasX, canvasY, size, z, tx, ty, errType = "Err") {
            console.warn(`Placeholder for error: ${errType} z${z},${tx},${ty} at approx canvas x:${canvasX}, y:${canvasY}`);
            // context.fillStyle = 'rgba(100,0,0,0.5)'; context.fillRect(canvasX, canvasY, size, size);
        }

        function createPolarCaps(parentMesh) {
            if (!parentMesh) return;
            const poleRadius = EARTH_RADIUS * 0.22;
            const poleSegments = 32;
            const poleMaterial = new THREE.MeshBasicMaterial({ color: 0xf0f5fa, side: THREE.DoubleSide });

            northPoleMeshGlobal = new THREE.Mesh(new THREE.CircleGeometry(poleRadius, poleSegments), poleMaterial);
            northPoleMeshGlobal.position.set(0, EARTH_RADIUS + 0.01, 0);
            northPoleMeshGlobal.rotation.x = -Math.PI / 2;
            parentMesh.add(northPoleMeshGlobal);

            southPoleMeshGlobal = new THREE.Mesh(new THREE.CircleGeometry(poleRadius, poleSegments), poleMaterial);
            southPoleMeshGlobal.position.set(0, -EARTH_RADIUS - 0.01, 0);
            southPoleMeshGlobal.rotation.x = Math.PI / 2;
            parentMesh.add(southPoleMeshGlobal);
        }

        // --- Astronomical Calculation Utilities ---
        function getJulianDate(date) { return (date.getTime() / 86400000.0) + 2440587.5; }
        function getGMST(jd_ut1) {
            const T = (jd_ut1 - 2451545.0) / 36525.0;
            let gmst = 280.46061837 + 360.98564736629 * (jd_ut1 - 2451545.0) + 0.000387933 * T * T - (T * T * T / 38710000.0);
            return (gmst % 360 + 360) % 360;
        }

        // --- Sun Position Calculation ---
        function getSunGeographicPosition(date) {
            const jday_UT = getJulianDate(date);
            const T = (jday_UT - 2451545.0) / 36525.0;
            let L_deg = (280.46645 + 36000.76983 * T + 0.0003032 * T * T); L_deg = (L_deg % 360 + 360) % 360;
            let M_deg = (357.52910 + 35999.05030 * T - 0.0001559 * T * T - 0.00000048 * T * T * T); M_deg = (M_deg % 360 + 360) % 360;
            const M_rad = M_deg * Math.PI / 180;
            const C1_coeff = (1.914602 - 0.004817 * T - 0.000014 * T * T); const C2_coeff = (0.019993 - 0.000101 * T); const C3_coeff = 0.000289;
            const C_deg = C1_coeff * Math.sin(M_rad) + C2_coeff * Math.sin(2 * M_rad) + C3_coeff * Math.sin(3 * M_rad);
            const lambda_true_deg = (L_deg + C_deg); const lambda_true_rad = ((lambda_true_deg % 360 + 360) % 360) * Math.PI / 180;
            const epsilon_deg = (23.439291 - 0.0130042 * T - 0.00000016 * T * T + 0.000000504 * T * T * T); const epsilon_rad = epsilon_deg * Math.PI / 180;
            const alpha_rad = Math.atan2(Math.cos(epsilon_rad) * Math.sin(lambda_true_rad), Math.cos(lambda_true_rad));
            const delta_rad = Math.asin(Math.sin(epsilon_rad) * Math.sin(lambda_true_rad));
            const subsolarLat_rad = delta_rad;
            const gmst_deg = getGMST(jday_UT); const gmst_rad = gmst_deg * Math.PI / 180;
            let alpha_normalized_rad = alpha_rad; if (alpha_normalized_rad < 0) alpha_normalized_rad += 2 * Math.PI;
            let subsolarLon_rad = alpha_normalized_rad - gmst_rad;
            while (subsolarLon_rad > Math.PI) subsolarLon_rad -= 2 * Math.PI; while (subsolarLon_rad < -Math.PI) subsolarLon_rad += 2 * Math.PI;
            return { latitude: subsolarLat_rad, longitude: subsolarLon_rad };
        }

        // --- Moon Position Calculation ---
        function getMoonPosition(date) {
            const jday_UT = getJulianDate(date); const T = (jday_UT - 2451545.0) / 36525.0;
            let L_prime_deg = (218.3164 + 481267.8813 * T); L_prime_deg = (L_prime_deg % 360 + 360) % 360;
            let M_prime_deg = (134.9634 + 477198.8675 * T); M_prime_deg = (M_prime_deg % 360 + 360) % 360;
            let F_deg = (93.2721 + 483202.0175 * T); F_deg = (F_deg % 360 + 360) % 360;
            let M_sun_deg = (357.5291 + 35999.0503 * T); M_sun_deg = (M_sun_deg % 360 + 360) % 360;
            let D_deg = (297.8502 + 445267.1115 * T); D_deg = (D_deg % 360 + 360) % 360;
            const M_prime_rad = M_prime_deg * Math.PI / 180; const F_rad = F_deg * Math.PI / 180; const D_rad = D_deg * Math.PI / 180; const M_sun_rad = M_sun_deg * Math.PI / 180; const L_prime_rad = L_prime_deg * Math.PI / 180;
            let sum_lon = 0; sum_lon += +6.288774 * Math.sin(M_prime_rad); sum_lon += -1.274027 * Math.sin(M_prime_rad - 2 * D_rad); sum_lon += +0.658314 * Math.sin(2 * D_rad); sum_lon += +0.213618 * Math.sin(2 * M_prime_rad); sum_lon += -0.185116 * Math.sin(M_sun_rad); sum_lon += -0.114332 * Math.sin(2 * F_rad);
            let sum_lat = 0; sum_lat += +5.128122 * Math.sin(F_rad); sum_lat += +0.280602 * Math.sin(M_prime_rad + F_rad); sum_lat += +0.277693 * Math.sin(M_prime_rad - F_rad); sum_lat += +0.173237 * Math.sin(2*D_rad - F_rad);
            let sum_dist = 0; sum_dist += -0.58 * Math.cos(M_prime_rad); sum_dist += -0.16 * Math.cos(M_prime_rad - 2*D_rad);
            const lambda_moon_rad = L_prime_rad + sum_lon * Math.PI / 180; const beta_moon_rad = sum_lat * Math.PI / 180; const distance_moon_ER = 60.2666 + sum_dist;
            const epsilon_deg = (23.439291 - 0.0130042 * T - 0.00000016 * T * T + 0.000000504 * T * T * T); const epsilon_rad = epsilon_deg * Math.PI / 180;
            const sin_epsilon = Math.sin(epsilon_rad); const cos_epsilon = Math.cos(epsilon_rad); const sin_lambda = Math.sin(lambda_moon_rad); const cos_lambda = Math.cos(lambda_moon_rad); const sin_beta = Math.sin(beta_moon_rad); const cos_beta = Math.cos(beta_moon_rad);
            const alpha_m_rad = Math.atan2(sin_lambda * cos_epsilon - Math.tan(beta_moon_rad) * sin_epsilon, cos_lambda);
            const delta_m_rad = Math.asin(sin_beta * cos_epsilon + cos_beta * sin_epsilon * sin_lambda);
            let alpha_m_normalized_rad = alpha_m_rad; if (alpha_m_normalized_rad < 0) alpha_m_normalized_rad += 2 * Math.PI;
            return { rightAscension: alpha_m_normalized_rad, declination: delta_m_rad, distance: distance_moon_ER };
        }

        // --- Update Sun and Moon Positions & Info Display ---
        function updateCelestialPositions() {
            if (!datePicker.value || !earthMesh) return;
            const dateStr = datePicker.value;
            const timeMinutes = parseInt(timeSlider.value, 10);
            const hours = Math.floor(timeMinutes / 60);
            const minutes = timeMinutes % 60;
            const currentDate = new Date(Date.UTC(
                parseInt(dateStr.substring(0, 4)), parseInt(dateStr.substring(5, 7)) - 1, parseInt(dateStr.substring(8, 10)),
                hours, minutes
            ));

            // --- Update Sun ---
            const subsolarPoint = getSunGeographicPosition(currentDate);
            let subsolarLatDeg = NaN;
            let subsolarLonDeg = NaN;
            let subsolarVec = new THREE.Vector3(1, 0, 0);

             if (subsolarPoint.error) {
                 console.error("Cannot update sun projection due to error in getSunGeographicPosition.");
                 if (sunProjectionMesh) sunProjectionMesh.visible = false;
                 if (sunMesh) sunMesh.visible = false;
             } else {
                 subsolarLatDeg = subsolarPoint.latitude * 180 / Math.PI;
                 subsolarLonDeg = subsolarPoint.longitude * 180 / Math.PI;
                 const sunDirection = new THREE.Vector3();
                 sunDirection.setFromSphericalCoords(1, Math.PI/2 - subsolarPoint.latitude,  Math.PI/2 + subsolarPoint.longitude);
                 subsolarVec.copy(sunDirection);

                 // Sun light position (far away, based on actual direction)
                 sunLight.position.copy(sunDirection.clone().multiplyScalar(EARTH_RADIUS * SUN_DISTANCE)); // Light source at realistic distance/direction
                 sunLight.target = earthMesh;

                 // Update Sun Globe position
                 if (sunMesh) {
                    const visualSunDistance = (EARTH_RADIUS * SUN_DISTANCE) / currentSunDistanceFactor;
                    sunMesh.position.copy(sunDirection.clone().multiplyScalar(visualSunDistance));
                    sunMesh.lookAt(earthMesh.position); // Optional: make it face Earth
                    sunMesh.visible = true;
                 }

                 // Update subsolar point marker
                 if (sunProjectionMesh) {
                     const projectionPosition = new THREE.Vector3();
                     projectionPosition.setFromSphericalCoords(EARTH_RADIUS + 0.03,
                            Math.PI / 2 - subsolarPoint.latitude,
                            Math.PI / 2 + subsolarPoint.longitude);
                     sunProjectionMesh.position.copy(projectionPosition);
                     sunProjectionMesh.lookAt(earthMesh.position);
                     sunProjectionMesh.visible = true;
                 }
             }

            // --- Update Moon ---
            let sublunarLatDeg = NaN;
            let sublunarLonDeg = NaN;
            let sublunarLatRad = NaN;
            let sublunarLonRad = NaN;
            let eclipseLatDeg = NaN;
            let eclipseLonDeg = NaN;
            let moonCartesian = new THREE.Vector3();
            let earthToMoonVecNormalized = new THREE.Vector3(0, 1, 0);

            if (moonMesh) {
                const moonPosGeo = getMoonPosition(currentDate);
                const visualMoonDistance = (EARTH_RADIUS * MOON_DISTANCE) / currentMoonDistanceFactor; // Use MOON_DISTANCE (actual) and factor

                const jday_UT = getJulianDate(currentDate);
                const gmst_deg = getGMST(jday_UT);
                const gmst_rad = gmst_deg * Math.PI / 180;

                sublunarLatRad = moonPosGeo.declination;
                sublunarLonRad = moonPosGeo.rightAscension - gmst_rad;

                while (sublunarLonRad > Math.PI) sublunarLonRad -= 2 * Math.PI;
                while (sublunarLonRad < -Math.PI) sublunarLonRad += 2 * Math.PI;

                sublunarLatDeg = sublunarLatRad * 180 / Math.PI;
                sublunarLonDeg = sublunarLonRad * 180 / Math.PI;

                moonCartesian.setFromSphericalCoords(
                    visualMoonDistance,
                    Math.PI / 2 - moonPosGeo.declination,
                    Math.PI / 2  + sublunarLonRad
                );
                moonMesh.position.copy(moonCartesian);
                moonMesh.lookAt(earthMesh.position);
                earthToMoonVecNormalized.copy(moonCartesian).normalize();


                if (moonProjectionMesh && !isNaN(sublunarLatRad) && !isNaN(sublunarLonRad)) {
                    const moonProjectionPosition = new THREE.Vector3();
                    moonProjectionPosition.setFromSphericalCoords(
                        EARTH_RADIUS + 0.031,
                        Math.PI / 2 - sublunarLatRad,
                        Math.PI / 2  + sublunarLonRad
                    );
                    moonProjectionMesh.position.copy(moonProjectionPosition);
                    moonProjectionMesh.lookAt(earthMesh.position);
                    moonProjectionMesh.visible = true;
                } else if (moonProjectionMesh) {
                     moonProjectionMesh.visible = false;
                }

            } else {
                 if (moonProjectionMesh) moonProjectionMesh.visible = false;
            }

            // --- Moon Shadow (Umbra) Logic ---
              // --- Moon Shadow (Umbra) Logic ---
              if (moonShadowMesh && moonMesh && !subsolarPoint.error && earthMesh && !isNaN(sublunarLatRad) && !isNaN(sublunarLonRad)) {
                // earthToMoonVecNormalized is the normalized vector from Earth center to Moon
                // subsolarVec is the normalized vector from Earth center to Sun
                
                const angleSunMoon = subsolarVec.angleTo(earthToMoonVecNormalized); // Angle between Sun and Moon vectors as seen from Earth's center

                // Check if Moon is roughly between Earth and Sun
                if (true) { //angleSunMoon < ECLIPSE_THRESHOLD_ANGLE_RAD) {
                    const aLatRad = sublunarLatRad - subsolarPoint.latitude;
                    const aLonRad = sublunarLonRad - subsolarPoint.longitude;
                    const bLonRad = Math.atan(Math.sin(aLonRad)/(SUN_DISTANCE/MOON_DISTANCE - Math.cos(aLonRad)));
                    const bLatRad = Math.atan(Math.sin(aLatRad)/(SUN_DISTANCE/MOON_DISTANCE - Math.cos(aLatRad)));
                    const cLatRad = Math.asin(SUN_DISTANCE*(1-1/SUN_DISTANCE)*Math.tan(bLatRad));
                    const cLonRad = Math.asin(SUN_DISTANCE*(1-1/SUN_DISTANCE)*Math.tan(bLonRad));
                    eclipseLatDeg = cLatRad * 180 / Math.PI;
                    eclipseLonDeg = cLonRad * 180 / Math.PI;
                    const shadowPosition = new THREE.Vector3();
                    // Position shadow at sublunar point on Earth's surface
                    shadowPosition.setFromSphericalCoords(
                        EARTH_RADIUS + 0.045, // Slightly above surface to avoid z-fighting, below other markers
                        Math.PI / 2 - cLatRad, // Colatitude for shadow
                        Math.PI / 2 + cLonRad  // Azimuth for shadow
                    );
                    moonShadowMesh.position.copy(shadowPosition);
                    moonShadowMesh.lookAt(earthMesh.position); // Orient shadow to lie flat on sphere
                    moonShadowMesh.visible = true;
                } else {
                    moonShadowMesh.visible = false; // Moon not aligned for eclipse
                }
            } else if (moonShadowMesh) {
                moonShadowMesh.visible = false; // Hide shadow if conditions not met
            }


            // Update the celestial info display
            if (celestialInfoDiv) {
                let infoText = "";
                if (!isNaN(subsolarLatDeg)) {
                    infoText += `Subsolar: ${subsolarLatDeg.toFixed(2)}° Lat, ${subsolarLonDeg.toFixed(2)}° Lon`;
                } else {
                    infoText += "Subsolar: Error";
                }
                infoText += "<br>";
                 if (!isNaN(sublunarLatDeg)) {
                    infoText += `Sublunar: ${sublunarLatDeg.toFixed(2)}° Lat, ${sublunarLonDeg.toFixed(2)}° Lon`;
                } else {
                    infoText += "Sublunar: Calculating...";
                }
                infoText += "<br>";
                 if (moonShadowMesh && moonShadowMesh.visible && !isNaN(eclipseLatDeg)) {
                    infoText += `Eclipse Shadow Approx: ${eclipseLatDeg.toFixed(2)}° Lat, ${eclipseLonDeg.toFixed(2)}° Lon`;
                } else {
                    infoText += "Eclipse Shadow: N/A";
                }
                celestialInfoDiv.innerHTML = infoText;
            }
        }

        function shiftEarth(dir10, dir1_1) {
            const _panDirectionVector = new THREE.Vector3();
            const _cameraLocal = new THREE.Vector3();
            _cameraLocal.setFromMatrixColumn(camera.matrixWorld, dir10);
            _panDirectionVector.copy(_cameraLocal).multiplyScalar(dir1_1 * CAMERA_SHIFT_AMOUNT);
            camera.position.add(_panDirectionVector);
            controls.target.add(_panDirectionVector);
            controls.update();
            updateEarthInfo();
        }

        function updateEarthInfo() {
            if (!camera || !controls || !earthMesh) { 
                earthInfoDiv.innerHTML = "Earth: Data unavailable";
                return;
            }
            let elat = NaN;
            let elon = NaN;

            camera.getWorldDirection(_viewDirection);
            _infoRaycaster.set(camera.position, _viewDirection);
            const intersects = _infoRaycaster.intersectObject(earthMesh, false); // 'false' for non-recursive intersection
            if (intersects.length > 0) {
                const intersectionPoint = intersects[0].point; // The closest intersection point on Earth's surface
                elat = Math.asin(intersectionPoint.y / intersectionPoint.length()) * (180 / Math.PI);
                elon = (Math.atan2(intersectionPoint.x, intersectionPoint.z) - Math.PI / 2) * (180 / Math.PI);
                elon = (elon + 540) % 360 - 180; // Normalizes to -180 to +180 range
            }
            let dist = (camera.position.length() - EARTH_RADIUS); // Distance in scene units
            let distKm = (dist / EARTH_RADIUS) * 6378; // Approximate km (if EARTH_RADIUS represents 6378km)
            if (!isNaN(elat) && !isNaN(elon)) {
                earthInfoDiv.innerHTML = `Earth: ${elat.toFixed(2)}° Lat, ${elon.toFixed(2)}° Lon, ${distKm.toFixed(0)} km Alt.`;
            } else {
                earthInfoDiv.innerHTML = `Earth: (View off globe), Altitude: ${distKm.toFixed(0)} km`;
            }

            // simplified version without panning
            // const surfacePoint = camera.position.clone().negate().normalize().multiplyScalar(EARTH_RADIUS);
            // let elat = -Math.asin(surfacePoint.y / EARTH_RADIUS) * (180 / Math.PI);
            // let elon = 180 + (Math.atan2(surfacePoint.x, surfacePoint.z) - Math.PI / 2) * (180 / Math.PI);
            // elon = (elon + 540) % 360 - 180;
            // let dist = (camera.position.length() - EARTH_RADIUS) / EARTH_RADIUS * 6378;
        }

        function zoomCamera(factor) {
            const currentDistance = camera.position.length();
            let newDistance = currentDistance * factor;
            newDistance = Math.max(controls.minDistance, Math.min(controls.maxDistance, newDistance));
            camera.position.setLength(newDistance);
            updateEarthInfo();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateEarthInfo();
        }

        let messageTimeout;
        function showMessage(text, type = "info", duration = 3000) {
            messageBox.textContent = text;
            if (type === "error") messageBox.style.backgroundColor = "rgba(200, 50, 50, 0.9)";
            else if (type === "loading") messageBox.style.backgroundColor = "rgba(50, 50, 150, 0.9)";
            else messageBox.style.backgroundColor = "rgba(50, 150, 50, 0.9)";

            messageBox.style.display = "block";
            clearTimeout(messageTimeout);
            if (duration > 0) {
                messageTimeout = setTimeout(() => { messageBox.style.display = "none"; }, duration);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

    </script>
</body>
</html>