<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Earth with Day Slider, Moon, Sun/Moon Positions, Shadow & Zoom</title>
    <style>
        body {
            margin: 0;
            font-family: 'Inter', sans-serif;
            background-color: #000;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden; /* Prevent scrollbars from appearing due to canvas/controls */
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        canvas {
            display: block; /* Remove extra space below canvas */
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(40, 40, 60, 0.85); /* Darker, slightly transparent background */
            padding: 15px;
            border-radius: 12px; /* Softer rounded corners */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3); /* More pronounced shadow */
            border: 1px solid rgba(255, 255, 255, 0.2); /* Subtle border */
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 12px; /* Space between control groups */
        }
        #controls label {
            font-size: 0.9em;
            margin-bottom: 3px;
        }
        #controls input[type="date"],
        #controls input[type="range"],
        #controls button {
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #555; /* Slightly lighter border for inputs */
            background-color: #333; /* Dark input background */
            color: #fff;
            font-size: 0.9em;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        #controls button:hover {
            background-color: #444; /* Darker hover for buttons */
        }
        #controls input[type="range"] {
            width: 150px; /* Fixed width for sliders */
        }
        .controlfield {
            font-size: 0.9em;
            margin-left: 8px;
            min-width: 45px; /* Ensure consistent width for value displays */
            display: inline-block;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .button-group {
            display: flex;
            gap: 8px;
        }
        .button-group-shift {
            /*display: flex;*/
            display: none;
            gap: 8px;
        }
        #messageBox {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 100, 100, 0.9); /* Default to error-like color, will be changed by JS */
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            z-index: 1000;
            display: none; /* Hidden by default */
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            font-size: 0.9em;
            text-align: center;
        }
        /* Style for Celestial Point Display */
        
        #overallInfo {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(40, 40, 60, 0.85);
            padding: 10px 15px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 10;
            font-size: 0.9em;
            line-height: 1.4;
            text-align: right;
            display: block; /* Hidden initially */
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="canvas-container">
        </div>
    <div id="controls">
        <div class="control-group">
            <label>Camera:</label>
            <div class="button-group">
                <button id="zoomInBtn">+</button>
                <button id="zoomOutBtn">-</button>
                <button id="hideEarthBtn">Off Earth</button>
                <button id="surfaceSatelliteBtn">To Surface</button> 
            </div>
            <div class="button-group-shift">
                <button id="shiftLeftBtn">←</button>
                <button id="shiftTopBtn">↑</button>
                <button id="shiftBotBtn">↓</button>
                <button id="shiftRightBtn">→</button>
            </div>
            
        </div>
        <div class="control-group">
            <label for="datePicker">Date:</label>
            <input type="date" id="datePicker">
        </div>
         <div class="control-group">
            <label for="dayOfYearSlider">Day of Year:</label>
            <div>
                <input type="range" id="dayOfYearSlider" min="1" max="366" value="1"> <span id="dayOfYearValue" class="controlfield">1</span>
            </div>
        </div>
        <div class="control-group">
            <label for="timeSlider">Time (UTC):</label>
            <div>
                <input type="range" id="timeSlider" min="0" max="1439" value="1080">
                <span id="timeValue" class="controlfield">18:00</span>
            </div>
        </div>
        <div class="control-group">
            <label for="tileZoomSlider">Map Tile Zoom (z):</label>
            <div>
                <input type="range" id="tileZoomSlider" min="3" max="6" value="4">
                <span id="tileZoomValue" class="controlfield">4</span>
            </div>
        </div>
        <div class="control-group">
            <label for="moonDistanceFactorSlider">Moon Distance Factor:</label>
            <div>
                <input type="range" id="moonDistanceFactorSlider" min="1" max="30" value="1" step="0.1">
                <span id="moonDistanceFactorValue" class="controlfield">1.0x</span>
            </div>
        </div>
        <div class="control-group">
            <label for="moonScaleFactorSlider">Moon Scale Factor:</label>
            <div>
                <input type="range" id="moonScaleFactorSlider" min="1" max="30" value="1" step="0.1">
                <span id="moonScaleFactorValue" class="controlfield">1.0x</span>
            </div>
        </div>
        <div class="control-group">
            <label for="sunDistanceFactorSlider">Sun Distance Factor:</label>
            <div>
                <input type="range" id="sunDistanceFactorSlider" min="1" max="30" value="1" step="0.1">
                <span id="sunDistanceFactorValue" class="controlfield">1.0x</span>
            </div>
        </div>
        <div class="control-group">
            <label for="sunScaleFactorSlider">Sun Scale Factor:</label>
            <div>
                <input type="range" id="sunScaleFactorSlider" min="1" max="30" value="1" step="0.1">
                <span id="sunScaleFactorValue" class="controlfield">1.0x</span>
            </div>
        </div>
    </div>

    <div id="overallInfo">
        <div id="earthInfo">Calculating...</div>
        <div id="celestialInfo">Calculating...</div>
    </div>
    <div id="messageBox"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // --- Global Variables ---
        let currentTileZoomLevel = 4; // Initial tile zoom level for map
        let isSatelliteViewMode = true;
        let globalElat = NaN, globalElon = NaN;
        let subsolarPoint;
        let isDragging = false, previousMouseX = 0, previousMouseY = 0;
        let rotationQuaternion = new THREE.Quaternion(), surfaceNormal;
        /// 3D
        let scene, camera, renderer, controls ;
        let sunMesh, sunProjectionMesh, sunLight; 
        let moonMesh, moonProjectionMesh, moonShadowMesh, moonPosGeo;
        let earthMesh, northPoleMeshGlobal, southPoleMeshGlobal; 
        let moonDistFactor = 1.0, sunDistFactor = 1.0, moonScaleFactor = 1.0, sunScaleFactor = 1.0;

        let _infoRaycaster = new THREE.Raycaster(); // For updateEarthInfo
        let _viewDirection = new THREE.Vector3(); 
        
        // --- Constants ---
        const FOV = 45;
        const EARTH_RADIUS = 5; // Arbitrary radius for Earth in scene units
        const EARTH_RADIUS_KM = 6378;
        const SURFACE_ALTITUDE = 200 * EARTH_RADIUS / EARTH_RADIUS_KM + EARTH_RADIUS;  // 200 km
        const DEFAULT_ALTITUDE = 5 * EARTH_RADIUS; 
        const LOOK_AT_DISTANCE = 50 * EARTH_RADIUS; 
        const CAMERA_SHIFT_AMOUNT = EARTH_RADIUS / 5;
        const MOON_DISTANCE = 60.3; // Actual average distance from Earth to Moon in Earth radii (used for camera controls, actual distance is dynamic)
        const SUN_DISTANCE = 23460; // Actual average distance from Earth to Sun in Earth radii (used for camera controls, actual distance is dynamic)
        const MOON_RADIUS = EARTH_RADIUS / 3.67; // Relative Moon radius
        const SUN_RADIUS_IN_EARTH_RADII = 109.0; // Sun's radius relative to Earth's radius
        const AU_IN_EARTH_RADII = 149597870.7 / EARTH_RADIUS_KM; // Approx 23455.9 Earth Radii for 1 AU
        // VISUAL_MOON_DISTANCE_FACTOR is now replaced by dynamic slider

        // Constants for Moon's Umbra (shadow)
        const MOON_SHADOW_COLOR = 0x4A2A00; // Dark orange for the shadow
        const MOON_SHADOW_OPACITY = 0.75;   // Opacity of the shadow
        const ECLIPSE_UMBRA_RADIUS_ON_EARTH_SCENE_UNITS = 0.35; // Visual radius of the umbra on Earth in scene units.
        const ECLIPSE_THRESHOLD_ANGLE_RAD = (0.60 * Math.PI / 180); // Max angular separation (Sun-Earth-Moon) to show umbra (degrees to radians)
                                                                   // A small angle means Sun and Moon must be closely aligned. Increased slightly for better visibility of shadow.

        const TILE_SERVER_URL_SCHEME = 'https://tile.openstreetmap.org/{z}/{x}/{y}.png'; // URL scheme for map tiles
        const TILE_CANVAS_SIZE = 4096; // Resolution of the canvas used to stitch map tiles

        // DOM Elements
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const shiftRightBtn = document.getElementById('shiftRightBtn');
        const shiftLeftBtn = document.getElementById('shiftLeftBtn');
        const shiftTopBtn = document.getElementById('shiftTopBtn');
        const shiftBotBtn = document.getElementById('shiftBotBtn');
        const hideEarthBtn = document.getElementById('hideEarthBtn');
        const datePicker = document.getElementById('datePicker');
        const dayOfYearSlider = document.getElementById('dayOfYearSlider');
        const dayOfYearValueDisplay = document.getElementById('dayOfYearValue');
        const timeSlider = document.getElementById('timeSlider');
        const timeValueDisplay = document.getElementById('timeValue');
        const tileZoomSlider = document.getElementById('tileZoomSlider');
        const tileZoomValueDisplay = document.getElementById('tileZoomValue');
        const moonDistanceFactorSlider = document.getElementById('moonDistanceFactorSlider');
        const moonDistanceFactorValue = document.getElementById('moonDistanceFactorValue');
        const sunDistanceFactorSlider = document.getElementById('sunDistanceFactorSlider');
        const sunDistanceFactorValue = document.getElementById('sunDistanceFactorValue');
        const moonScaleFactorSlider = document.getElementById('moonScaleFactorSlider');
        const moonScaleFactorValue = document.getElementById('moonScaleFactorValue');
        const sunScaleFactorSlider = document.getElementById('sunScaleFactorSlider');
        const sunScaleFactorValue = document.getElementById('sunScaleFactorValue');
        
        const canvasContainer = document.getElementById('canvas-container');
        const messageBox = document.getElementById('messageBox');
        const celestialInfoDiv = document.getElementById('celestialInfo');
        const earthInfoDiv = document.getElementById('earthInfo');
        const surfaceSatelliteBtn = document.getElementById('surfaceSatelliteBtn'); // New Button

        // --- Helper Functions ---
        // Checks if a given year is a leap year
        function isLeap(year) {
            return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
        }

        // Gets the day number (1-365 or 1-366) for a given UTC date
        function getDayOfYear(date) {
            const start = new Date(Date.UTC(date.getUTCFullYear(), 0, 0)); // Start of the year
            const diff = date.getTime() - start.getTime(); // Difference in milliseconds
            const oneDay = 1000 * 60 * 60 * 24; // Milliseconds in a day
            return Math.floor(diff / oneDay);
        }

        // Gets a UTC date from a year and a day number
        function getDateFromDay(year, day) {
            const date = new Date(Date.UTC(year, 0)); // Initialize to Jan 1st of the year
            return new Date(date.setUTCDate(day)); // Set the day of the year
        }

        // Formats a Date object into yyyy-MM-DD string
        function formatDate(date) {
            const yyyy = date.getUTCFullYear();
            const mm = String(date.getUTCMonth() + 1).padStart(2, '0'); // Months are 0-indexed
            const dd = String(date.getUTCDate()).padStart(2, '0');
            return `${yyyy}-${mm}-${dd}`;
        }

        // --- Initialization ---
        async function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510); // Dark space background

            // Camera setup
            camera = new THREE.PerspectiveCamera(FOV, window.innerWidth / window.innerHeight, 0.01, EARTH_RADIUS * SUN_DISTANCE * 1.2); // Adjusted far plane
            camera.position.set(0, 0, DEFAULT_ALTITUDE); // Initial camera position
            camera.lookAt(0, 0, 0); // Look at the center of the scene (Earth)

            const nearPlaneCenterMarkerGeometry = new THREE.CircleGeometry(camera.near * 0.01, 16); 
            const nearPlaneCenterMarkerMaterial = new THREE.MeshBasicMaterial({
                color: 0xbb0000,        // Bright red for visibility
                side: THREE.DoubleSide, // Render both sides
                transparent:true,
                opacity:0.4
            });
            const nearPlaneCenterMarker = new THREE.Mesh(nearPlaneCenterMarkerGeometry, nearPlaneCenterMarkerMaterial);
            nearPlaneCenterMarker.position.set(0, 0,  -camera.near*2);
            camera.add(nearPlaneCenterMarker);

            scene.add(camera);
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // For sharp rendering on high DPI screens
            canvasContainer.appendChild(renderer.domElement); // Add canvas to the container

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x606060, 1.5); // Soft ambient light
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(0xffffff, 3.0); // Main light source (Sun)
            scene.add(sunLight);


            // --- Sun Globe ---
            const sunGeometry = new THREE.SphereGeometry(EARTH_RADIUS * SUN_RADIUS_IN_EARTH_RADII, 64, 64);
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xFFE45A, wireframe: false }); // Bright yellow, non-emissive for simplicity
            sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.scale.set(1, 1, 1);
            sunMesh.visible = false; // Initially hidden until position is calculated
            scene.add(sunMesh);


            // --- Sun Projection Circle (Subsolar Point Marker) ---
            const sunProjGeom = new THREE.CircleGeometry(EARTH_RADIUS * 0.008, 32); // Small circle
            const sunProjMat = new THREE.MeshBasicMaterial({ color: 0xFFFF00, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
            sunProjectionMesh = new THREE.Mesh(sunProjGeom, sunProjMat);
            sunProjectionMesh.visible = false; // Initially hidden
            scene.add(sunProjectionMesh);

            // --- Moon Projection Circle (Sublunar Point Marker) ---
            const moonProjGeom = new THREE.CircleGeometry(EARTH_RADIUS * 0.008, 32); // Small circle
            const moonProjMat = new THREE.MeshBasicMaterial({ color: 0xAAAAFF, transparent: true, opacity: 0.6, side: THREE.DoubleSide }); // Light blue/grey
            moonProjectionMesh = new THREE.Mesh(moonProjGeom, moonProjMat);
            moonProjectionMesh.visible = false; // Initially hidden
            scene.add(moonProjectionMesh);


            // --- Moon ---
            const moonGeometry = new THREE.SphereGeometry(MOON_RADIUS, 32, 32);
            const moonMaterial = new THREE.MeshPhongMaterial({ color: 0xaaaaaa, shininess: 5, specular: 0x111111 });
            moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
            scene.add(moonMesh);

            // --- Moon Shadow (Umbra) ---
            const shadowGeometry = new THREE.CircleGeometry(ECLIPSE_UMBRA_RADIUS_ON_EARTH_SCENE_UNITS, 32);
            const shadowMaterial = new THREE.MeshBasicMaterial({
                color: MOON_SHADOW_COLOR,
                transparent: true,
                opacity: MOON_SHADOW_OPACITY,
                side: THREE.DoubleSide
            });
            moonShadowMesh = new THREE.Mesh(shadowGeometry, shadowMaterial);
            moonShadowMesh.visible = false; // Initially hidden
            scene.add(moonShadowMesh);


            // --- Earth ---
            try {
                await updateEarthTiles(currentTileZoomLevel); // Load initial map tiles
                // Initial date setup and sync
                //const today = new Date(); // Original
                const today = new Date("2026-08-12T"+timeValueDisplay.textContent+":00Z"); // Example date, ensure UTC interpretation
                datePicker.value = formatDate(today);
                syncDaySliderToDate(); // Sync day slider to the initial date

                // Initialize slider values from HTML defaults
                moonDistFactor = parseFloat(moonDistanceFactorSlider.value);
                moonDistanceFactorValue.textContent = `${moonDistFactor.toFixed(1)}x`;
                sunDistFactor = parseFloat(sunDistanceFactorSlider.value);
                sunDistanceFactorValue.textContent = `${sunDistFactor.toFixed(1)}x`;
                moonScaleFactor = parseFloat(moonScaleFactorSlider.value);
                moonScaleFactorSlider.textContent = `${moonScaleFactor.toFixed(1)}x`;
                sunScaleFactor = parseFloat(sunScaleFactorSlider.value);
                sunScaleFactorSlider.textContent = `${sunScaleFactor.toFixed(1)}x`;

                updateCelestialPositions(); // Calculate initial Sun/Moon positions
            } catch (error) {
                console.error("Error during initial scene setup:", error);
                showMessage("Failed to initialize Earth. Please refresh.", "error", 10000);
            }



            // --- Controls (OrbitControls for camera interaction) ---
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Smooth camera movement
            controls.dampingFactor = 0.05;
            controls.minDistance = EARTH_RADIUS + 0.01; // Prevent zooming inside Earth
            controls.maxDistance = EARTH_RADIUS * SUN_DISTANCE * 1.1; // Adjusted max zoom out
            controls.enablePan = true; // Enable panning (original comment was misleading)

            // --- UI Event Listeners ---
            zoomInBtn.addEventListener('click', () => zoomCamera(0.7));
            zoomOutBtn.addEventListener('click', () => zoomCamera(1.4));
            shiftLeftBtn.addEventListener('click', () => shiftEarth(0, 1));
            shiftRightBtn.addEventListener('click', () => shiftEarth(0, -1));
            shiftTopBtn.addEventListener('click', () => shiftEarth(1, -1));
            shiftBotBtn.addEventListener('click', () => shiftEarth(1, 1));
            window.addEventListener('keydown', (event) => {
                if (!isSatelliteViewMode && event.target == document.body) {
                    if (event.key === 'ArrowLeft') {
                        shiftEarth(0, 1); 
                    } else if (event.key === 'ArrowRight') {
                        shiftEarth(0, -1); 
                    } else if (event.key === 'ArrowUp') {
                        shiftEarth(1, -1); 
                    } else if (event.key === 'ArrowDown') {
                        shiftEarth(1, 1); 
                    }
                }
            });
            hideEarthBtn.addEventListener('click', () => {
                hideEarthBtn.textContent = earthMesh.visible ? "On Earth" : "Off Earth";
                earthMesh.visible = !earthMesh.visible
            });
            surfaceSatelliteBtn.addEventListener('click', toggleSurfaceSatelliteMode); // New listener
            datePicker.addEventListener('change', () => {
                syncDaySliderToDate();
                updateCelestialPositions();
            });

            dayOfYearSlider.addEventListener('input', () => {
                syncDateToDaySlider();
                updateCelestialPositions();
            });

            timeSlider.addEventListener('input', () => {
                const minutes = parseInt(timeSlider.value);
                const h = Math.floor(minutes / 60);
                const m = minutes % 60;
                timeValueDisplay.textContent = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
                updateCelestialPositions();
            });

            tileZoomSlider.addEventListener('input', async (event) => {
                const newZoomLevel = parseInt(event.target.value);
                tileZoomValueDisplay.textContent = newZoomLevel;
                if (newZoomLevel !== currentTileZoomLevel) {
                    currentTileZoomLevel = newZoomLevel;
                    showMessage(`Loading tiles for zoom level ${currentTileZoomLevel}... This may take a moment.`, "info", 0);
                    await updateEarthTiles(currentTileZoomLevel);
                    updateCelestialPositions();
                }
            });

            moonScaleFactorSlider.addEventListener('input', () => {
                moonScaleFactor = parseFloat(moonScaleFactorSlider.value);
                moonScaleFactorValue.textContent = `${moonScaleFactor.toFixed(1)}x`;
                updateCelestialPositions();
            });
            sunScaleFactorSlider.addEventListener('input', () => {
                sunScaleFactor = parseFloat(sunScaleFactorSlider.value);
                sunScaleFactorValue.textContent = `${sunScaleFactor.toFixed(1)}x`;
                updateCelestialPositions();
            });
            moonDistanceFactorSlider.addEventListener('input', () => {
                moonDistFactor = parseFloat(moonDistanceFactorSlider.value);
                moonDistanceFactorValue.textContent = `${moonDistFactor.toFixed(1)}x`;
                updateCelestialPositions();
            });

            sunDistanceFactorSlider.addEventListener('input', () => {
                sunDistFactor = parseFloat(sunDistanceFactorSlider.value);
                sunDistanceFactorValue.textContent = `${sunDistFactor.toFixed(1)}x`;
                updateCelestialPositions();
            });

            document.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMouseX = e.clientX;
                previousMouseY = e.clientY;
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging || isSatelliteViewMode) return;
                const deltaX = e.clientX - previousMouseX;
                const deltaY = e.clientY - previousMouseY;
                rotateSkyInSurfaceMode(deltaX / 20, -deltaY / 20);
            });
            window.addEventListener('resize', onWindowResize);
            controls.addEventListener('change', function() {
                updateEarthInfo();
            });
            animate();
            updateEarthInfo();
        }

        // --- Date/Day Slider Synchronization ---
        function syncDaySliderToDate() {
            const dateStr = datePicker.value;
            if (!dateStr) return;
            const year = parseInt(dateStr.substring(0, 4));
            const month = parseInt(dateStr.substring(5, 7)) - 1;
            const day = parseInt(dateStr.substring(8, 10));
            const currentUtcDate = new Date(Date.UTC(year, month, day));
            const dayNum = getDayOfYear(currentUtcDate);
            dayOfYearSlider.max = isLeap(year) ? 366 : 365;
            dayOfYearSlider.value = dayNum;
            dayOfYearValueDisplay.textContent = dayNum;
        }

        function syncDateToDaySlider() {
            const dayNum = parseInt(dayOfYearSlider.value);
            const dateStr = datePicker.value;
            let year = new Date().getUTCFullYear();
             if (dateStr) {
                 year = parseInt(dateStr.substring(0, 4));
             } else {
                 datePicker.value = formatDate(getDateFromDay(year, 1));
             }
            dayOfYearSlider.max = isLeap(year) ? 366 : 365;
            const newDate = getDateFromDay(year, dayNum);
            datePicker.value = formatDate(newDate);
            dayOfYearValueDisplay.textContent = dayNum;
        }


        // --- Mercator Tile to Geographic Coordinate Helpers ---
        function tile2lon(x, z) { return x / Math.pow(2, z) * 360 - 180; }
        function tile2lat(y, z) { const n = Math.PI - 2 * Math.PI * y / Math.pow(2, z); return 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n))); }
        function getTileGeoBounds(tileX, tileY, zoom) {
            const lon1 = tile2lon(tileX, zoom); const lat1 = tile2lat(tileY, zoom);
            const lon2 = tile2lon(tileX + 1, zoom); const lat2 = tile2lat(tileY + 1, zoom);
            return { minLon: lon1, maxLon: lon2, minLat: lat2, maxLat: lat1 };
        }

        // --- Earth Tile Update ---
        async function updateEarthTiles(zoomLevel) {
             if (earthMesh) {
                scene.remove(earthMesh);
                if (earthMesh.geometry) earthMesh.geometry.dispose();
                if (earthMesh.material && earthMesh.material.map) earthMesh.material.map.dispose();
                if (earthMesh.material) earthMesh.material.dispose();
                earthMesh = null;
            }
            if(northPoleMeshGlobal && northPoleMeshGlobal.parent) northPoleMeshGlobal.parent.remove(northPoleMeshGlobal);
            if(southPoleMeshGlobal && southPoleMeshGlobal.parent) southPoleMeshGlobal.parent.remove(southPoleMeshGlobal);
            northPoleMeshGlobal = null; southPoleMeshGlobal = null;

            const earthGeometry = new THREE.SphereGeometry(EARTH_RADIUS, 128, 128);
            const numTilesPerDimension = Math.pow(2, zoomLevel);
            const tilesToLoad = [];
            for (let y = 0; y < numTilesPerDimension; y++) { for (let x = 0; x < numTilesPerDimension; x++) { tilesToLoad.push({ z: zoomLevel, x: x, y: y }); } }

            const tileCanvas = document.createElement('canvas');
            tileCanvas.width = TILE_CANVAS_SIZE; tileCanvas.height = TILE_CANVAS_SIZE;
            const ctx = tileCanvas.getContext('2d');
            ctx.fillStyle = '#102030';
            ctx.fillRect(0, 0, tileCanvas.width, tileCanvas.height);

            const textureLoader = new THREE.TextureLoader();
            textureLoader.setCrossOrigin("anonymous");
            let loadedCount = 0; const totalTiles = tilesToLoad.length; let progressLastShown = 0;

            const promises = tilesToLoad.map(tileInfo => {
                const tileUrl = TILE_SERVER_URL_SCHEME.replace('{z}', tileInfo.z).replace('{x}', tileInfo.x).replace('{y}', tileInfo.y);
                return new Promise((resolve) => {
                    textureLoader.load(tileUrl, (texture) => {
                            const image = texture.image;
                            try {
                                const geoBounds = getTileGeoBounds(tileInfo.x, tileInfo.y, zoomLevel);
                                const destX = ((geoBounds.minLon + 180) / 360) * TILE_CANVAS_SIZE;
                                const destMaxX = ((geoBounds.maxLon + 180) / 360) * TILE_CANVAS_SIZE;
                                const destY = ((90 - geoBounds.maxLat) / 180) * TILE_CANVAS_SIZE;
                                const destMaxY = ((90 - geoBounds.minLat) / 180) * TILE_CANVAS_SIZE;
                                const destWidth = destMaxX - destX; const destHeight = destMaxY - destY;
                                if (destWidth > 0 && destHeight > 0) { ctx.drawImage(image, 0, 0, image.width, image.height, destX, destY, destWidth, destHeight); }
                            } catch (e) { console.error(`Error processing/drawing tile ${tileUrl} to canvas:`, e); }
                            loadedCount++; const progress = Math.floor((loadedCount / totalTiles) * 100);
                            if (progress > progressLastShown + 5 || loadedCount === totalTiles) {
                                showMessage(`Loading tiles: ${progress}% complete...`, "loading", loadedCount === totalTiles ? 1000 : 0); progressLastShown = progress;
                            } resolve();
                        }, undefined, (error) => {
                            console.error(`Failed to load tile image: ${tileUrl}`, error);
                            drawErrorPlaceholder(ctx, tileInfo.x * (TILE_CANVAS_SIZE / numTilesPerDimension), tileInfo.y * (TILE_CANVAS_SIZE / numTilesPerDimension), (TILE_CANVAS_SIZE / numTilesPerDimension), zoomLevel, tileInfo.x, tileInfo.y, "LoadErr");
                            loadedCount++; const progress = Math.floor((loadedCount / totalTiles) * 100);
                             if (progress > progressLastShown + 5 || loadedCount === totalTiles) {
                                showMessage(`Loading tiles (some errors): ${progress}% complete...`, "loading", loadedCount === totalTiles ? 1000 : 0); progressLastShown = progress;
                            } resolve();
                        } ); }); });

            await Promise.all(promises);
            showMessage(`All ${totalTiles} tile requests for zoom ${zoomLevel} processed.`, "info", 4000);

            const earthTexture = new THREE.CanvasTexture(tileCanvas);
            earthTexture.colorSpace = THREE.SRGBColorSpace;
            earthTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            earthTexture.needsUpdate = true;
            const earthMaterial = new THREE.MeshPhongMaterial({ map: earthTexture, shininess: 10, specular: 0x101010 });
            earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
            scene.add(earthMesh);
            createPolarCaps(earthMesh);
        }

        function drawErrorPlaceholder(context, canvasX, canvasY, size, z, tx, ty, errType = "Err") {
            console.warn(`Placeholder for error: ${errType} z${z},${tx},${ty} at approx canvas x:${canvasX}, y:${canvasY}`);
            // context.fillStyle = 'rgba(100,0,0,0.5)'; context.fillRect(canvasX, canvasY, size, size);
        }

        function createPolarCaps(parentMesh) {
            if (!parentMesh) return;
            const poleRadius = EARTH_RADIUS * 0.22;
            const poleSegments = 32;
            const poleMaterial = new THREE.MeshBasicMaterial({ color: 0xf0f5fa, side: THREE.DoubleSide });

            northPoleMeshGlobal = new THREE.Mesh(new THREE.CircleGeometry(poleRadius, poleSegments), poleMaterial);
            northPoleMeshGlobal.position.set(0, EARTH_RADIUS + 0.001, 0);
            northPoleMeshGlobal.rotation.x = -Math.PI / 2;
            parentMesh.add(northPoleMeshGlobal);

            southPoleMeshGlobal = new THREE.Mesh(new THREE.CircleGeometry(poleRadius, poleSegments), poleMaterial);
            southPoleMeshGlobal.position.set(0, -EARTH_RADIUS - 0.001, 0);
            southPoleMeshGlobal.rotation.x = Math.PI / 2;
            parentMesh.add(southPoleMeshGlobal);
        }

        // --- Astronomical Calculation Utilities ---
        function getJulianDate(date) { return (date.getTime() / 86400000.0) + 2440587.5; }
        function getGMST(jd_ut1) {
            const T = (jd_ut1 - 2451545.0) / 36525.0;
            let gmst = 280.46061837 + 360.98564736629 * (jd_ut1 - 2451545.0) + 0.000387933 * T * T - (T * T * T / 38710000.0);
            return (gmst % 360 + 360) % 360;
        }

        // --- Sun Position Calculation ---
        function getSunGeographicPosition(date) {
            const jday_UT = getJulianDate(date);
            const T = (jday_UT - 2451545.0) / 36525.0;
            let L_deg = (280.46645 + 36000.76983 * T + 0.0003032 * T * T); L_deg = (L_deg % 360 + 360) % 360;
            let M_deg = (357.52910 + 35999.05030 * T - 0.0001559 * T * T - 0.00000048 * T * T * T); M_deg = (M_deg % 360 + 360) % 360;
            const M_rad = M_deg * Math.PI / 180;
            const C1_coeff = (1.914602 - 0.004817 * T - 0.000014 * T * T); const C2_coeff = (0.019993 - 0.000101 * T); const C3_coeff = 0.000289;
            const C_deg = C1_coeff * Math.sin(M_rad) + C2_coeff * Math.sin(2 * M_rad) + C3_coeff * Math.sin(3 * M_rad);
            const lambda_true_deg = (L_deg + C_deg); const lambda_true_rad = ((lambda_true_deg % 360 + 360) % 360) * Math.PI / 180;
            const epsilon_deg = (23.439291 - 0.0130042 * T - 0.00000016 * T * T + 0.000000504 * T * T * T); const epsilon_rad = epsilon_deg * Math.PI / 180;
            const alpha_rad = Math.atan2(Math.cos(epsilon_rad) * Math.sin(lambda_true_rad), Math.cos(lambda_true_rad));
            const delta_rad = Math.asin(Math.sin(epsilon_rad) * Math.sin(lambda_true_rad));
            const subsolarLat_rad = delta_rad;
            const gmst_deg = getGMST(jday_UT); const gmst_rad = gmst_deg * Math.PI / 180;
            let alpha_normalized_rad = alpha_rad; if (alpha_normalized_rad < 0) alpha_normalized_rad += 2 * Math.PI;
            let subsolarLon_rad = alpha_normalized_rad - gmst_rad;
            while (subsolarLon_rad > Math.PI) subsolarLon_rad -= 2 * Math.PI; while (subsolarLon_rad < -Math.PI) subsolarLon_rad += 2 * Math.PI;
            
            // Calculate Sun-Earth distance using elliptic orbit formula (approximation)
            // R_AU = 1.00014 - 0.01671 * cos(M_rad) - 0.00014 * cos(2 * M_rad)
            const e_earth = 0.01671; // Earth's orbital eccentricity (approx)
            const R_AU = 1.00014 - e_earth * Math.cos(M_rad) - 0.00014 * Math.cos(2 * M_rad);
            const sunDistanceER = R_AU * AU_IN_EARTH_RADII;

            return { latitude: subsolarLat_rad, longitude: subsolarLon_rad, distance: sunDistanceER, error: null };
        }

        // --- Moon Position Calculation ---
        function getMoonPosition(date) {
            const jday_UT = getJulianDate(date); const T = (jday_UT - 2451545.0) / 36525.0;
            let L_prime_deg = (218.3164 + 481267.8813 * T); L_prime_deg = (L_prime_deg % 360 + 360) % 360;
            let M_prime_deg = (134.9634 + 477198.8675 * T); M_prime_deg = (M_prime_deg % 360 + 360) % 360;
            let F_deg = (93.2721 + 483202.0175 * T); F_deg = (F_deg % 360 + 360) % 360;
            let M_sun_deg = (357.5291 + 35999.0503 * T); M_sun_deg = (M_sun_deg % 360 + 360) % 360;
            let D_deg = (297.8502 + 445267.1115 * T); D_deg = (D_deg % 360 + 360) % 360;
            const M_prime_rad = M_prime_deg * Math.PI / 180; const F_rad = F_deg * Math.PI / 180; const D_rad = D_deg * Math.PI / 180; const M_sun_rad = M_sun_deg * Math.PI / 180; const L_prime_rad = L_prime_deg * Math.PI / 180;
            let sum_lon = 0; sum_lon += +6.288774 * Math.sin(M_prime_rad); sum_lon += -1.274027 * Math.sin(M_prime_rad - 2 * D_rad); sum_lon += +0.658314 * Math.sin(2 * D_rad); sum_lon += +0.213618 * Math.sin(2 * M_prime_rad); sum_lon += -0.185116 * Math.sin(M_sun_rad); sum_lon += -0.114332 * Math.sin(2 * F_rad);
            let sum_lat = 0; sum_lat += +5.128122 * Math.sin(F_rad); sum_lat += +0.280602 * Math.sin(M_prime_rad + F_rad); sum_lat += +0.277693 * Math.sin(M_prime_rad - F_rad); sum_lat += +0.173237 * Math.sin(2*D_rad - F_rad);
            let sum_dist = 0; sum_dist += -0.58 * Math.cos(M_prime_rad); sum_dist += -0.16 * Math.cos(M_prime_rad - 2*D_rad); // These terms adjust for elliptical orbit + perturbations
            const distance_moon_ER = 60.2666 + sum_dist; // Mean distance (60.2666 ER) + perturbations
            const lambda_moon_rad = L_prime_rad + sum_lon * Math.PI / 180; const beta_moon_rad = sum_lat * Math.PI / 180; 
            const epsilon_deg = (23.439291 - 0.0130042 * T - 0.00000016 * T * T + 0.000000504 * T * T * T); const epsilon_rad = epsilon_deg * Math.PI / 180;
            const sin_epsilon = Math.sin(epsilon_rad); const cos_epsilon = Math.cos(epsilon_rad); const sin_lambda = Math.sin(lambda_moon_rad); const cos_lambda = Math.cos(lambda_moon_rad); const sin_beta = Math.sin(beta_moon_rad); const cos_beta = Math.cos(beta_moon_rad);
            const alpha_m_rad = Math.atan2(sin_lambda * cos_epsilon - Math.tan(beta_moon_rad) * sin_epsilon, cos_lambda);
            const delta_m_rad = Math.asin(sin_beta * cos_epsilon + cos_beta * sin_epsilon * sin_lambda);
            let alpha_m_normalized_rad = alpha_m_rad; if (alpha_m_normalized_rad < 0) alpha_m_normalized_rad += 2 * Math.PI;
            return { rightAscension: alpha_m_normalized_rad, declination: delta_m_rad, distance: distance_moon_ER };
        }

        // --- Update Sun and Moon Positions & Info Display ---
        function updateCelestialPositions() {
            if (!datePicker.value || !earthMesh) return;
            const dateStr = datePicker.value;
            const timeMinutes = parseInt(timeSlider.value, 10);
            const hours = Math.floor(timeMinutes / 60);
            const minutes = timeMinutes % 60;
            const currentDate = new Date(Date.UTC(
                parseInt(dateStr.substring(0, 4)), parseInt(dateStr.substring(5, 7)) - 1, parseInt(dateStr.substring(8, 10)),
                hours, minutes
            ));

            // --- Update Sun ---
            const sunData = getSunGeographicPosition(currentDate);
            subsolarPoint = { latitude: sunData.latitude, longitude: sunData.longitude }; // Keep subsolarPoint structure for compatibility if used elsewhere
            let actualSunDistanceER = sunData.distance; // This is in Earth Radii

            let subsolarLatDeg = NaN;
            let subsolarLonDeg = NaN;
            let subsolarVec = new THREE.Vector3(1, 0, 0);

             if (sunData.error) { // Check if getSunGeographicPosition itself had an error
                 console.error("Cannot update sun projection due to error in getSunGeographicPosition.");
                 if (sunProjectionMesh) sunProjectionMesh.visible = false;
                 if (sunMesh) sunMesh.visible = false;
             } else {
                 subsolarLatDeg = sunData.latitude * 180 / Math.PI;
                 subsolarLonDeg = sunData.longitude * 180 / Math.PI;
                 const sunDirection = new THREE.Vector3();
                 sunDirection.setFromSphericalCoords(1, Math.PI/2 - sunData.latitude,  Math.PI/2 + sunData.longitude);
                 subsolarVec.copy(sunDirection);

                 // Sun light position (far away, based on actual direction and distance)
                 sunLight.position.copy(sunDirection.clone().multiplyScalar(EARTH_RADIUS * actualSunDistanceER)); 
                 sunLight.target = earthMesh;

                 // Update Sun Globe position
                 if (sunMesh) {
                    const visualSunDistance = (EARTH_RADIUS * actualSunDistanceER) / sunDistFactor;
                    sunMesh.position.copy(sunDirection.clone().multiplyScalar(visualSunDistance));
                    sunMesh.scale.set(sunScaleFactor, sunScaleFactor, sunScaleFactor);
                    sunMesh.lookAt(earthMesh.position); // Optional: make it face Earth
                    sunMesh.visible = true;
                 }

                 // Update subsolar point marker
                 if (sunProjectionMesh) {
                     const projectionPosition = new THREE.Vector3();
                     projectionPosition.setFromSphericalCoords(EARTH_RADIUS + 0.03,
                            Math.PI / 2 - sunData.latitude,
                            Math.PI / 2 + sunData.longitude);
                     sunProjectionMesh.position.copy(projectionPosition);
                     sunProjectionMesh.lookAt(earthMesh.position);
                     sunProjectionMesh.visible = true;
                 }
             }

            // --- Update Moon ---
            let sublunarLatDeg = NaN;
            let sublunarLonDeg = NaN;
            let sublunarLatRad = NaN;
            let sublunarLonRad = NaN;
            let eclipseLatDeg = NaN;
            let eclipseLonDeg = NaN;
            let moonCartesian = new THREE.Vector3();
            let earthToMoonVecNormalized = new THREE.Vector3(0, 1, 0);

            if (moonMesh) {
                moonPosGeo = getMoonPosition(currentDate);
                const actualMoonDistanceER = moonPosGeo.distance; // Already in Earth Radii from getMoonPosition
                const visualMoonDistance = (EARTH_RADIUS * actualMoonDistanceER) / moonDistFactor; 

                const jday_UT = getJulianDate(currentDate);
                const gmst_deg = getGMST(jday_UT);
                const gmst_rad = gmst_deg * Math.PI / 180;

                sublunarLatRad = moonPosGeo.declination;
                sublunarLonRad = moonPosGeo.rightAscension - gmst_rad;

                while (sublunarLonRad > Math.PI) sublunarLonRad -= 2 * Math.PI;
                while (sublunarLonRad < -Math.PI) sublunarLonRad += 2 * Math.PI;

                sublunarLatDeg = sublunarLatRad * 180 / Math.PI;
                sublunarLonDeg = sublunarLonRad * 180 / Math.PI;

                moonCartesian.setFromSphericalCoords(
                    visualMoonDistance, // Use the visual distance calculated with the factor
                    Math.PI / 2 - moonPosGeo.declination,
                    Math.PI / 2  + sublunarLonRad 
                );
                moonMesh.position.copy(moonCartesian);
                moonMesh.scale.set(moonScaleFactor, moonScaleFactor, moonScaleFactor);
                moonMesh.lookAt(earthMesh.position);
                earthToMoonVecNormalized.copy(moonCartesian).normalize();

                if (moonProjectionMesh && !isNaN(sublunarLatRad) && !isNaN(sublunarLonRad)) {
                    const moonProjectionPosition = new THREE.Vector3();
                    moonProjectionPosition.setFromSphericalCoords(
                        EARTH_RADIUS + 0.031,
                        Math.PI / 2 - sublunarLatRad,
                        Math.PI / 2  + sublunarLonRad
                    );
                    moonProjectionMesh.position.copy(moonProjectionPosition);
                    moonProjectionMesh.lookAt(earthMesh.position);
                    moonProjectionMesh.visible = true;
                } else if (moonProjectionMesh) {
                     moonProjectionMesh.visible = false;
                }

            } else {
                 if (moonProjectionMesh) moonProjectionMesh.visible = false;
            }

            // --- Shadow where center of Sun hidden by Moon ---
            if (moonShadowMesh && moonMesh && !sunData.error && earthMesh && !isNaN(sublunarLatRad) && !isNaN(sublunarLonRad)) {
                const angleSunMoon = subsolarVec.angleTo(earthToMoonVecNormalized); 
                const sunPos = sunMesh.position;
                const moonPos = moonMesh.position;
                const direction = new THREE.Vector3();
                direction.subVectors(moonPos, sunPos).normalize();
                const raycaster = new THREE.Raycaster(moonPos, direction);
                const intersects = raycaster.intersectObject(earthMesh, false); // 'false' means don't check children
                eclipseLatDeg = NaN;
                eclipseLonDeg = NaN;
                moonShadowMesh.visible = false; 
                if (intersects.length > 0) {
                    const intersectionPoint = intersects[0].point;
                    const latitudeRad = Math.asin(intersectionPoint.y / intersectionPoint.length());
                    let longitudeRad = Math.atan2(intersectionPoint.x, intersectionPoint.z) - Math.PI / 2;
                        // Convert radians to degrees
                    eclipseLatDeg = latitudeRad * (180 / Math.PI);
                    eclipseLonDeg = longitudeRad * (180 / Math.PI);
                    eclipseLonDeg = (eclipseLonDeg + 540) % 360 - 180;
                    const shadowPosition = new THREE.Vector3();
                    shadowPosition.setFromSphericalCoords(
                        EARTH_RADIUS + 0.045, 
                        Math.PI / 2 - latitudeRad, 
                        Math.PI / 2 + longitudeRad  
                    );
                    moonShadowMesh.position.copy(shadowPosition);
                    moonShadowMesh.lookAt(earthMesh.position); 
                    moonShadowMesh.visible = true;
                } else if (false) { // Simple method
                    const sunDistRatio = actualSunDistanceER / moonPosGeo.distance; // Ratio of actual distances
                    const aLatRad = sublunarLatRad - sunData.latitude;
                    const aLonRad = sublunarLonRad - sunData.longitude;
                    const bLonRad = Math.atan(Math.sin(aLonRad)/(sunDistRatio - Math.cos(aLonRad)));
                    const bLatRad = Math.atan(Math.sin(aLatRad)/(sunDistRatio - Math.cos(aLatRad)));
                    const cLatRad = Math.asin(actualSunDistanceER*(1-1/actualSunDistanceER)*Math.tan(bLatRad)); 
                    const cLonRad = Math.asin(actualSunDistanceER*(1-1/actualSunDistanceER)*Math.tan(bLonRad)); 
                    
                    eclipseLatDeg = cLatRad * 180 / Math.PI;
                    eclipseLonDeg = cLonRad * 180 / Math.PI;
                    const shadowPosition = new THREE.Vector3();
                    shadowPosition.setFromSphericalCoords(
                        EARTH_RADIUS + 0.045, 
                        Math.PI / 2 - cLatRad, 
                        Math.PI / 2 + cLonRad  
                    );
                    moonShadowMesh.position.copy(shadowPosition);
                    moonShadowMesh.lookAt(earthMesh.position); 
                    moonShadowMesh.visible = true;
                }
            }


            // Update the celestial info display
            if (celestialInfoDiv) {
                let infoText = "";
                if (!isNaN(subsolarLatDeg)) {
                    infoText += `Sun: ${subsolarLatDeg.toFixed(2)}° Lat, ${subsolarLonDeg.toFixed(2)}° Lon,
                         ${(actualSunDistanceER / AU_IN_EARTH_RADII / sunDistFactor).toFixed(2)} AU`;
                } else {
                    infoText += "Subsolar: Error";
                }
                infoText += "<br>";
                 if (!isNaN(sublunarLatDeg) && moonPosGeo) {
                    infoText += `Moon: ${sublunarLatDeg.toFixed(2)}° Lat, ${sublunarLonDeg.toFixed(2)}° Lon, 
                                ${(moonPosGeo.distance / moonDistFactor).toFixed(2)} ER`;
                } else {
                    infoText += "Sublunar: Calculating...";
                }
                infoText += "<br>";
                 if (moonShadowMesh && moonShadowMesh.visible && !isNaN(eclipseLatDeg)) {
                    infoText += `Eclipse Shadow Approx: ${eclipseLatDeg.toFixed(2)}° Lat, ${eclipseLonDeg.toFixed(2)}° Lon`;
                } else {
                    infoText += "Eclipse Shadow: N/A";
                }
                celestialInfoDiv.innerHTML = infoText;
            }
        }

        function shiftEarth(dir10, dir1_1) {
            if (isSatelliteViewMode) {
                const _panDirectionVector = new THREE.Vector3();
                const _cameraLocal = new THREE.Vector3();
                _cameraLocal.setFromMatrixColumn(camera.matrixWorld, dir10);
                _panDirectionVector.copy(_cameraLocal).multiplyScalar(dir1_1 * CAMERA_SHIFT_AMOUNT);
                camera.position.add(_panDirectionVector);
                controls.target.add(_panDirectionVector);
                controls.update();
            } else {
                const sense = 50;
                rotateSkyInSurfaceMode(dir10 == 0 ? dir1_1 * sense : 0, dir10 == 1 ? dir1_1 * sense: 0)
            }
            updateEarthInfo();
        }

        function updateEarthInfo() {
            if (isSatelliteViewMode) {
                globalElat = NaN; globalElon = NaN; // Reset global lat/lon
                if (camera && controls && earthMesh) { 
                    camera.getWorldDirection(_viewDirection);
                    _infoRaycaster.set(camera.position, _viewDirection);
                    const intersects = _infoRaycaster.intersectObject(earthMesh, false); 
                    if (intersects.length > 0) {
                        const intersectionPoint = intersects[0].point; 
                        globalElat = Math.asin(intersectionPoint.y / intersectionPoint.length()) * (180 / Math.PI);
                        globalElon = (Math.atan2(intersectionPoint.x, intersectionPoint.z) - Math.PI / 2) * (180 / Math.PI);
                        globalElon = (globalElon + 540) % 360 - 180; 
                    }
                }
            }
            let dist = (camera.position.length() - EARTH_RADIUS); 
            let distKm = (dist / EARTH_RADIUS) * EARTH_RADIUS_KM; 
            if (!isNaN(globalElat) && !isNaN(globalElon)) {
                earthInfoDiv.innerHTML = `Earth: ${globalElat.toFixed(2)}° Lat, ${globalElon.toFixed(2)}° Lon, ${distKm.toFixed(0)} km Alt.`;
            } else {
                earthInfoDiv.innerHTML = `Earth: (View off globe), Altitude: ${distKm.toFixed(0)} km`;
            }
            // simplified version without panning
            // const surfacePoint = camera.position.clone().negate().normalize().multiplyScalar(EARTH_RADIUS);
            // let elat = -Math.asin(surfacePoint.y / EARTH_RADIUS) * (180 / Math.PI);
            // let elon = 180 + (Math.atan2(surfacePoint.x, surfacePoint.z) - Math.PI / 2) * (180 / Math.PI);
            // elon = (elon + 540) % 360 - 180;
            // let dist = (camera.position.length() - EARTH_RADIUS) / EARTH_RADIUS * 6378;
        }

        function rotateSkyInSurfaceMode(deltaX, deltaY) {
            const sensitivity = (2 * Math.tan(FOV/2 * Math.PI/180)) / window.innerHeight;            
            // Get current look direction
            const lookDirection = new THREE.Vector3();
            camera.getWorldDirection(lookDirection);
            // Rotate direction into local frame (Y-axis aligned with surface normal)
            const localLookDir = lookDirection.clone().applyQuaternion(rotationQuaternion);
            // Convert to local spherical coordinates
            const localSpherical = new THREE.Spherical().setFromVector3(localLookDir);
            if (localSpherical.phi == 0) {
                localSpherical.theta = 0;
            }
            // Adjust angles based on mouse movement
            localSpherical.theta -= deltaX * sensitivity; // Azimuth
            localSpherical.phi = Math.max(0, Math.min(Math.PI, localSpherical.phi - deltaY * sensitivity));
            // console.log("L "+ (localSpherical.phi / Math.PI * 180) + " " + (localSpherical.theta / Math.PI * 180));            
            // Convert back to local direction
            const newLocalLookDir = new THREE.Vector3().setFromSpherical(localSpherical);
            // Rotate back to global frame
            const newGlobalLookDir = newLocalLookDir.applyQuaternion(rotationQuaternion.clone().invert());    
            // Calculate target point and update camera
            const targetPoint = camera.position.clone().add(newGlobalLookDir);
            camera.lookAt(targetPoint);
            camera.up.copy(surfaceNormal.clone().negate()); 


            // let currentLookAtPoint = new THREE.Vector3();
            // camera.getWorldDirection(currentLookAtPoint);
            // initialSpherical.setFromVector3(currentLookAtPoint);
            // console.log("M "+ (initialSpherical.phi / Math.PI * 180) + " " + (initialSpherical.theta / Math.PI * 180));            
        }

        function toggleSurfaceSatelliteMode() {
            if (isNaN(globalElat)) {
                showMessage("Not pointing at Earth surface", "error", 2000);
                return;
            }
            surfaceSatelliteBtn.textContent = !isSatelliteViewMode ?  "To Surface" : "To Satellite";
            isSatelliteViewMode = !isSatelliteViewMode;
            const phi = (90 - globalElat) * Math.PI / 180;
            const theta = (globalElon + 90) * Math.PI / 180;
            const surfacePoint = new THREE.Vector3().setFromSphericalCoords(EARTH_RADIUS, phi, theta).normalize();
            if (!isSatelliteViewMode) {
                // Position camera at surface
                camera.position.copy(surfacePoint.multiplyScalar(SURFACE_ALTITUDE));
                surfaceNormal = new THREE.Vector3().copy(surfacePoint).normalize();
                rotationQuaternion.setFromUnitVectors(surfaceNormal, new THREE.Vector3(0, -1, 0));
                // 1. Look straight down
                camera.lookAt(camera.position.clone().add(surfaceNormal.negate()));
                // // rotateSkyInSurfaceMode(0, 0);
                camera.up.set(0, 1, 0); 
                // 2. Look middle todo
                // const newLocalLookDir = new THREE.Vector3().set(0, 0, 1);
                // const newGlobalLookDir = newLocalLookDir.applyQuaternion(rotationQuaternion.clone().invert());   
                // camera.lookAt(camera.position.clone().add(newGlobalLookDir));
                // camera.up.copy(surfaceNormal.clone().negate()); 
            } else {
                camera.position.copy(surfacePoint.multiplyScalar(DEFAULT_ALTITUDE));
                camera.lookAt(0, 0, 0);
                camera.up.set(0, 1, 0); 
            }
            controls.enabled = isSatelliteViewMode;
            controls.enablePan = isSatelliteViewMode;
            controls.enableZoom = isSatelliteViewMode;
            controls.enableRotate = isSatelliteViewMode;
            updateEarthInfo();
        }

        function zoomCamera(factor) {
            const currentDistance = camera.position.length();
            let newDistance = (currentDistance - EARTH_RADIUS) * factor + EARTH_RADIUS;
            newDistance = Math.max(controls.minDistance, Math.min(controls.maxDistance, newDistance));
            camera.position.setLength(newDistance);
            updateEarthInfo();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateEarthInfo();
        }

        let messageTimeout;
        function showMessage(text, type = "info", duration = 3000) {
            messageBox.textContent = text;
            if (type === "error") messageBox.style.backgroundColor = "rgba(200, 50, 50, 0.9)";
            else if (type === "loading") messageBox.style.backgroundColor = "rgba(50, 50, 150, 0.9)";
            else messageBox.style.backgroundColor = "rgba(50, 150, 50, 0.9)";

            messageBox.style.display = "block";
            clearTimeout(messageTimeout);
            if (duration > 0) {
                messageTimeout = setTimeout(() => { messageBox.style.display = "none"; }, duration);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (isSatelliteViewMode) {
                controls.update();
            }
            renderer.render(scene, camera);
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

    </script>
</body>
</html>